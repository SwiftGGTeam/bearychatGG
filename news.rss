<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<atom:link href="http://developer.apple.com/swift/blog/news.rss" rel="self" type="application/rss+xml" />
<title>Swift Blog - Apple Developer</title>
<link>http://developer.apple.com/swift/blog/</link>
<description>Get the latest news and helpful tips on the Swift programming language from the engineers who created it.</description>
<language>en-US</language>
<lastBuildDate>Wed, 12 Aug 2015 13:25:00 PDT</lastBuildDate>
<generator>Custom</generator>
<copyright>Copyright 2015, Apple Inc.</copyright>

<item>
<title>Swift-er SDK</title>
<link>http://developer.apple.com/swift/blog/?id=31</link>
<guid>http://developer.apple.com/swift/blog/?id=31</guid>
<description> In Xcode 6.3 we added the new  nullability annotations  language feature for Objective-C. This feature gave Objective-C a way to express the same sorts of null and non-null API contracts that Optionals provide in Swift. Xcode 7 continues to make communication between Objective-C and Swift more natural by introducing a lightweight generics model for Objective-C. Generics enable the two languages to safely understand and share collections containing specific kinds of elements.  These features are useful for anyone writing apps that contain both Swift and Objective-C code. But there‚Äôs a much larger collection of Objective-C code that app developers use every day: the frameworks that make up the Apple SDKs. To improve the experience of working with Swift  and  with Objective-C, we made a company-wide effort to provide this information in our SDK headers. In Xcode 7 you‚Äôll find that nearly all of the common frameworks now specify the nullability of their APIs and the elements of their collection types. This takes our Swift interface from this:  [view code in blog]  To this:  [view code in blog]  The last piece of the puzzle is the Xcode 7 tool to convert your code to Swift 2. This tool lives in Xcode under the Edit menu as Convert &#x0200B;&gt; To Latest Swift Syntax. The tool takes a project that uses Swift 1.2 and applies the necessary edits to turn your code into valid Swift 2 code. These changes account for the improved header information. For instance, if you are overriding a method whose parameter and result types are now more precise, the migrator will update your method to match.  The improvements to Objective-C were detailed at WWDC in  Swift and Objective-C Interoperability  starting at the 14:30 mark. Note that this video uses the Xcode 6.3  __nullable  syntax as opposed to the updated syntax in Xcode 7 that uses  _Nullable . For more information on nullability annotations, see the blog post  Nullability and Objective-C . For more information on Swift 2 and Objective-C lightweight generics, see the  Xcode 7 Release Notes . </description>
<pubDate>Wed, 12 Aug 2015 13:25:00 PDT</pubDate>
<content:encoded><![CDATA[<p>In Xcode 6.3 we added the new <a href="https://developer.apple.com/swift/blog/?id=25">nullability annotations</a> language feature for Objective-C. This feature gave Objective-C a way to express the same sorts of null and non-null API contracts that Optionals provide in Swift. Xcode 7 continues to make communication between Objective-C and Swift more natural by introducing a lightweight generics model for Objective-C. Generics enable the two languages to safely understand and share collections containing specific kinds of elements.</p><p>These features are useful for anyone writing apps that contain both Swift and Objective-C code. But there‚Äôs a much larger collection of Objective-C code that app developers use every day: the frameworks that make up the Apple SDKs. To improve the experience of working with Swift <em>and</em> with Objective-C, we made a company-wide effort to provide this information in our SDK headers. In Xcode 7 you‚Äôll find that nearly all of the common frameworks now specify the nullability of their APIs and the elements of their collection types. This takes our Swift interface from this:</p><a href="http://developer.apple.com/swift/blog/?id=31">[view code in blog]</a><p>To this:</p><a href="http://developer.apple.com/swift/blog/?id=31">[view code in blog]</a><p>The last piece of the puzzle is the Xcode 7 tool to convert your code to Swift 2. This tool lives in Xcode under the Edit menu as Convert &#x0200B;&gt; To Latest Swift Syntax. The tool takes a project that uses Swift 1.2 and applies the necessary edits to turn your code into valid Swift 2 code. These changes account for the improved header information. For instance, if you are overriding a method whose parameter and result types are now more precise, the migrator will update your method to match.</p><p>The improvements to Objective-C were detailed at WWDC in <a href="https://developer.apple.com/videos/wwdc/2015/?id=401">Swift and Objective-C Interoperability</a> starting at the 14:30 mark. Note that this video uses the Xcode 6.3 <span class="keyword">__nullable</span> syntax as opposed to the updated syntax in Xcode 7 that uses <span class="keyword">_Nullable</span>. For more information on nullability annotations, see the blog post <a href="https://developer.apple.com/swift/blog/?id=25">Nullability and Objective-C</a>. For more information on Swift 2 and Objective-C lightweight generics, see the <a href="https://developer.apple.com/go/?id=xcode7-beta-release-notes">Xcode 7 Release Notes</a>.</p>]]></content:encoded>
</item>
<item>
<title>Strings in Swift 2</title>
<link>http://developer.apple.com/swift/blog/?id=30</link>
<guid>http://developer.apple.com/swift/blog/?id=30</guid>
<description> Swift provides a performant, Unicode-compliant string implementation as part of its Standard Library. In Swift 2, the  String  type no longer conforms to the  CollectionType  protocol, where  String  was previously a collection of  Character  values, similar to an array. Now,  String  provides a  characters  property that exposes a character collection view.  Why the change? Although it may seem natural to model a string as a collection of characters, the  String  type behaves quite differently from collection types like  Array ,  Set , or  Dictionary . This has always been true, but with the addition of protocol extensions to Swift 2 these differences made it necessary to make several fundamental changes.  Different Than the Sum of Its Parts  When you add an element to a collection, you expect that the collection will contain that element. That is, when you append a value to an array, the array then contains that value. The same applies to a dictionary or a set. However, when you append a combining mark character to a string, the contents of the string itself change.  Consider the string  cafe , which has four characters:  c ,  a ,  f , and  e :  [view code in blog]  If you append the combining acute accent character  U+0301   ¬¥  the string still has four characters, but the last character is now  √© :  [view code in blog]  The string‚Äôs  characters  property does not contain the original lowercase  e , nor does it contain the combining acute accent  ¬¥  that was just appended. Instead, the string now contains a lowercase ‚Äúe‚Äù with acute accent  √© :  [view code in blog]  If we were to treat strings like any other collection, this result would be as surprising as adding  UIColor.redColor()  and  UIColor.greenColor()  to a set and the set then reporting that it contains  UIColor.yellowColor() .  Judged by the Contents of Its Characters  Another difference between strings and collections is the way they determine equality.   Two arrays are equal only if both have the same count, and each pair of elements at corresponding indices are equal.  Two sets are equal only if both have the same count, and each element contained in the first set is also contained in the second.  Two dictionaries are equal only if they have the same set of key, value pairs.   However,  String  determines equality based on being  canonically equivalent . Characters are canonically equivalent if they have the same linguistic meaning and appearance, even if they are composed from different Unicode scalars behind the scenes.  Consider the Korean writing system, which consists of 24 letters, or  Jamo , representing individual consonants and vowels. When written out these letters are combined into characters for each syllable. For example, the character ‚ÄúÍ∞Ä‚Äù ([ga]) is composed of the letters ‚Äú·ÑÄ‚Äù ([g]) and ‚Äú·Ö°‚Äù [a]. In Swift, strings are considered equal regardless of whether they are constructed from decomposed or precomposed character sequences:  [view code in blog]  Again, this behavior differs greatly from any of Swift‚Äôs collection types. It would be as surprising as an array with values  üêü  and  üçö  being considered equal to  üç£ .  Depends on Your Point of View  Strings are not collections. But they do provide  views  that conform to  CollectionType :    characters  is a collection of  Character  values, or  extended grapheme clusters .   unicodeScalars  is a collection of  Unicode scalar values .   utf8  is a collection of  UTF&amp;#8211;8  code units.   utf16  is a collection of  UTF&amp;#8211;16  code units.   If we take the previous example of the word ‚Äúcaf√©‚Äù, comprised of the decomposed characters [ c, a, f, e ] and [ ¬¥ ], here's what the various string views would consist of:    The  characters  property segments the text into  extended grapheme clusters , which are an approximation of user-perceived characters (in this case: c, a, f, and √©). Because a string must iterate through each of its positions within the overall string (each position is called a code point) in order to determine character boundaries, accessing this property is executed in linear  O(n)  time. When processing strings that contain human-readable text, high-level locale-sensitive Unicode algorithms, such as those used by the  localizedStandardCompare(_:)  method and the  localizedLowercaseString  property, should be preferred to character-by-character processing.  The  unicodeScalars  property exposes the underlying scalar values stored in the string. If the original string were created with the precomposed character  √©  instead of the decomposed  e  +  ¬¥ , this would be reflected by the Unicode scalars view. Use this API when you are performing low-level manipulation of character data.  The  utf8  and  utf16  properties provide code points for the UTF‚Äì8 and UTF‚Äì16 representations, respectively. These values correspond to the actual bytes written to a file when translated to and from a particular encoding. UTF-8 code units are used by many POSIX string processing APIs, whereas UTF-16 code units are used throughout Cocoa &amp; Cocoa Touch to represent string lengths and offsets.   For more information about working with Strings and Characters in Swift, read  The Swift Programming Language  and the  Swift Standard Library Reference . </description>
<pubDate>Thu, 23 Jul 2015 14:30:00 PDT</pubDate>
<content:encoded><![CDATA[<p>Swift provides a performant, Unicode-compliant string implementation as part of its Standard Library. In Swift 2, the <span class="keyword">String</span> type no longer conforms to the <span class="keyword">CollectionType</span> protocol, where <span class="keyword">String</span> was previously a collection of <span class="keyword">Character</span> values, similar to an array. Now, <span class="keyword">String</span> provides a <span class="keyword">characters</span> property that exposes a character collection view.</p><p>Why the change? Although it may seem natural to model a string as a collection of characters, the <span class="keyword">String</span> type behaves quite differently from collection types like <span class="keyword">Array</span>, <span class="keyword">Set</span>, or <span class="keyword">Dictionary</span>. This has always been true, but with the addition of protocol extensions to Swift 2 these differences made it necessary to make several fundamental changes.</p><h3>Different Than the Sum of Its Parts</h3><p>When you add an element to a collection, you expect that the collection will contain that element. That is, when you append a value to an array, the array then contains that value. The same applies to a dictionary or a set. However, when you append a combining mark character to a string, the contents of the string itself change.</p><p>Consider the string <span class="keyword">cafe</span>, which has four characters: <span class="keyword">c</span>, <span class="keyword">a</span>, <span class="keyword">f</span>, and <span class="keyword">e</span>:</p><a href="http://developer.apple.com/swift/blog/?id=30">[view code in blog]</a><p>If you append the combining acute accent character <span class="keyword">U+0301</span> <span class="keyword">¬¥</span> the string still has four characters, but the last character is now <span class="keyword">√©</span>:</p><a href="http://developer.apple.com/swift/blog/?id=30">[view code in blog]</a><p>The string‚Äôs <span class="keyword">characters</span> property does not contain the original lowercase <span class="keyword">e</span>, nor does it contain the combining acute accent <span class="keyword">¬¥</span> that was just appended. Instead, the string now contains a lowercase ‚Äúe‚Äù with acute accent <span class="keyword">√©</span>:</p><a href="http://developer.apple.com/swift/blog/?id=30">[view code in blog]</a><p>If we were to treat strings like any other collection, this result would be as surprising as adding <span class="keyword">UIColor.redColor()</span> and <span class="keyword">UIColor.greenColor()</span> to a set and the set then reporting that it contains <span class="keyword">UIColor.yellowColor()</span>.</p><h3>Judged by the Contents of Its Characters</h3><p>Another difference between strings and collections is the way they determine equality.</p><ul><li>Two arrays are equal only if both have the same count, and each pair of elements at corresponding indices are equal.</li><li>Two sets are equal only if both have the same count, and each element contained in the first set is also contained in the second.</li><li>Two dictionaries are equal only if they have the same set of key, value pairs.</li></ul><p>However, <span class="keyword">String</span> determines equality based on being <em>canonically equivalent</em>. Characters are canonically equivalent if they have the same linguistic meaning and appearance, even if they are composed from different Unicode scalars behind the scenes.</p><p>Consider the Korean writing system, which consists of 24 letters, or <em>Jamo</em>, representing individual consonants and vowels. When written out these letters are combined into characters for each syllable. For example, the character ‚ÄúÍ∞Ä‚Äù ([ga]) is composed of the letters ‚Äú·ÑÄ‚Äù ([g]) and ‚Äú·Ö°‚Äù [a]. In Swift, strings are considered equal regardless of whether they are constructed from decomposed or precomposed character sequences:</p><a href="http://developer.apple.com/swift/blog/?id=30">[view code in blog]</a><p>Again, this behavior differs greatly from any of Swift‚Äôs collection types. It would be as surprising as an array with values <span class="keyword">üêü</span> and <span class="keyword">üçö</span> being considered equal to <span class="keyword">üç£</span>.</p><h3>Depends on Your Point of View</h3><p>Strings are not collections. But they do provide <em>views</em> that conform to <span class="keyword">CollectionType</span>:</p><ul><li><span class="keyword">characters</span> is a collection of <span class="keyword">Character</span> values, or <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Strings/Articles/stringsClusters.html">extended grapheme clusters</a>.</li><li><span class="keyword">unicodeScalars</span> is a collection of <a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode scalar values</a>.</li><li><span class="keyword">utf8</span> is a collection of <a href="http://www.unicode.org/glossary/#UTF_8">UTF&amp;#8211;8</a> code units.</li><li><span class="keyword">utf16</span> is a collection of <a href="http://www.unicode.org/glossary/#UTF_16">UTF&amp;#8211;16</a> code units.</li></ul><p>If we take the previous example of the word ‚Äúcaf√©‚Äù, comprised of the decomposed characters [ c, a, f, e ] and [ ¬¥ ], here's what the various string views would consist of:</p><img alt="" src="https://devimages.apple.com.edgekey.net/swift/blog/images/swift-string-views.png" width="650" height="312"><ul><li>The <span class="keyword">characters</span> property segments the text into <em>extended grapheme clusters</em>, which are an approximation of user-perceived characters (in this case: c, a, f, and √©). Because a string must iterate through each of its positions within the overall string (each position is called a code point) in order to determine character boundaries, accessing this property is executed in linear <span class="keyword">O(n)</span> time. When processing strings that contain human-readable text, high-level locale-sensitive Unicode algorithms, such as those used by the <span class="keyword">localizedStandardCompare(_:)</span> method and the <span class="keyword">localizedLowercaseString</span> property, should be preferred to character-by-character processing.</li><li>The <span class="keyword">unicodeScalars</span> property exposes the underlying scalar values stored in the string. If the original string were created with the precomposed character <span class="keyword">√©</span> instead of the decomposed <span class="keyword">e</span> + <span class="keyword">¬¥</span>, this would be reflected by the Unicode scalars view. Use this API when you are performing low-level manipulation of character data.</li><li>The <span class="keyword">utf8</span> and <span class="keyword">utf16</span> properties provide code points for the UTF‚Äì8 and UTF‚Äì16 representations, respectively. These values correspond to the actual bytes written to a file when translated to and from a particular encoding. UTF-8 code units are used by many POSIX string processing APIs, whereas UTF-16 code units are used throughout Cocoa &amp; Cocoa Touch to represent string lengths and offsets.</li></ul><p>For more information about working with Strings and Characters in Swift, read <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html#//apple_ref/doc/uid/TP40014097-CH7-ID285">The Swift Programming Language</a> and the <a href="https://developer.apple.com/library/prerelease/ios//documentation/Swift/Reference/Swift_String_Structure/index.html#//apple_ref/swift/struct/s:SS">Swift Standard Library Reference</a>.</p>]]></content:encoded>
</item>
<item>
<title>Swift 2.0</title>
<link>http://developer.apple.com/swift/blog/?id=29</link>
<guid>http://developer.apple.com/swift/blog/?id=29</guid>
<description> Today at WWDC, we announced  Swift 2.0 .  This new version has even better performance, a new error handling API, and first-class support for availability checking. And platform APIs feel even more natural in Swift with enhancements to the  Apple SDKs .  Open Source  In addition to new features, the big news is that Apple will be making Swift open source later this year.  We are all incredibly excited about this, and look forward to giving you a lot more information as the open source release gets nearer.  Here is what we can tell you so far:   Swift source code will be released under an OSI-approved permissive license.  Contributions from the community will be accepted ‚Äî and encouraged.  At launch we intend to contribute ports for  OS X , iOS, and Linux.  Source code will include the Swift compiler and standard library.  We think it would be amazing for Swift to be on all your favorite platforms.   We are excited about the opportunities an open source Swift creates for our industry.  Baked-in safety features combined with excellent speed mean it has the chance to dramatically improve software versus using C-based languages.  Swift is packed with modern features, it‚Äôs fun to write, and we believe it will get used in a lot of places.  Together, we have an exciting road ahead.  New Features   Swift 2.0  also includes a lot of new language features and refinements. Expect to see blog posts exploring the features in more depth, and be sure to watch for the WWDC sessions covering these topics all this week. A few of the new features include:   Error handling model:  The new error handling model in  Swift 2.0  will instantly feel natural, with familiar   try ,  throw , and  catch  keywords.  Best of all, it was designed to work perfectly with the  Apple SDKs  and  NSError .  In fact,  NSError  conforms to a Swift‚Äôs  ErrorType .  You‚Äôll definitely want to watch the WWDC session on What‚Äôs New in Swift to hear more about it.   Availability:  Using the latest SDKs ensures you get access to new features and information about platform changes.  But sometimes you still need to target an older OS, and Swift makes doing so much easier and safer.  The Swift compiler now shows an error when you use an API that is too new for your target OS, and  #available  blocks can safely wrap lines of code to only run when on the right OS versions.   Protocol extensions:  Swift is very focused on protocol-oriented development ‚Äî there‚Äôs even a session on the topic at  WWDC 2015 .   Swift 2.0  adds protocol extensions, and the standard library itself uses them extensively.  Where you used to use global functions,  Swift 2.0  now adds methods to common types so functions chain naturally, and your code is much more readable.   Swift-er SDKs:   Swift 2  works even better with the  Apple SDKs , thanks in part to two new features in Objective-C:  nullability annotations and generics.  The SDKs have been updated to annotate API that cannot return  nil  so you don‚Äôt need to use optionals as often.  And with a true generics system employed by the SDKs you can more often preserve detailed type information in your  Swift 2  code.  Learn more  This is just a taste of what‚Äôs new in  Swift 2 .  You can download the latest version of  The Swift Programming Language  from the  iBooks Store , and be sure to watch the WWDC sessions live streamed and on video throughout the week.  And to read more, visit  http://developer.apple.com/swift  </description>
<pubDate>Mon, 08 Jun 2015 12:00:00 PDT</pubDate>
<content:encoded><![CDATA[<p>Today at WWDC, we announced <span class="nowrap">Swift 2.0</span>.  This new version has even better performance, a new error handling API, and first-class support for availability checking. And platform APIs feel even more natural in Swift with enhancements to the <span class="nowrap">Apple SDKs</span>.</p><h3>Open Source</h3><p>In addition to new features, the big news is that Apple will be making Swift open source later this year.  We are all incredibly excited about this, and look forward to giving you a lot more information as the open source release gets nearer.  Here is what we can tell you so far:</p><ul><li>Swift source code will be released under an OSI-approved permissive license.</li><li>Contributions from the community will be accepted ‚Äî and encouraged.</li><li>At launch we intend to contribute ports for <span class="nowrap">OS X</span>, iOS, and Linux.</li><li>Source code will include the Swift compiler and standard library.</li><li>We think it would be amazing for Swift to be on all your favorite platforms.</li></ul><p>We are excited about the opportunities an open source Swift creates for our industry.  Baked-in safety features combined with excellent speed mean it has the chance to dramatically improve software versus using C-based languages.  Swift is packed with modern features, it‚Äôs fun to write, and we believe it will get used in a lot of places.  Together, we have an exciting road ahead.</p><h3>New Features</h3><p><span class="nowrap">Swift 2.0</span> also includes a lot of new language features and refinements. Expect to see blog posts exploring the features in more depth, and be sure to watch for the WWDC sessions covering these topics all this week. A few of the new features include:</p><p><strong>Error handling model: </strong>The new error handling model in <span class="nowrap">Swift 2.0</span> will instantly feel natural, with familiar  <span class="keyword">try</span>, <span class="keyword">throw</span>, and <span class="keyword">catch</span> keywords.  Best of all, it was designed to work perfectly with the <span class="nowrap">Apple SDKs</span> and <span class="keyword">NSError</span>.  In fact, <span class="keyword">NSError</span> conforms to a Swift‚Äôs <span class="keyword">ErrorType</span>.  You‚Äôll definitely want to watch the WWDC session on What‚Äôs New in Swift to hear more about it.</p><p><strong>Availability: </strong>Using the latest SDKs ensures you get access to new features and information about platform changes.  But sometimes you still need to target an older OS, and Swift makes doing so much easier and safer.  The Swift compiler now shows an error when you use an API that is too new for your target OS, and <span class="keyword">#available</span> blocks can safely wrap lines of code to only run when on the right OS versions.</p><p><strong>Protocol extensions: </strong>Swift is very focused on protocol-oriented development ‚Äî there‚Äôs even a session on the topic at <span class="nowrap">WWDC 2015</span>.  <span class="nowrap">Swift 2.0</span> adds protocol extensions, and the standard library itself uses them extensively.  Where you used to use global functions, <span class="nowrap">Swift 2.0</span> now adds methods to common types so functions chain naturally, and your code is much more readable.</p><p><strong>Swift-er SDKs: </strong><span class="nowrap">Swift 2</span> works even better with the <span class="nowrap">Apple SDKs</span>, thanks in part to two new features in Objective-C:  nullability annotations and generics.  The SDKs have been updated to annotate API that cannot return <span class="keyword">nil</span> so you don‚Äôt need to use optionals as often.  And with a true generics system employed by the SDKs you can more often preserve detailed type information in your <span class="nowrap">Swift 2</span> code.</p><h3>Learn more</h3><p>This is just a taste of what‚Äôs new in <span class="nowrap">Swift 2</span>.  You can download the latest version of <em>The Swift Programming Language</em> from the <span class="nowrap">iBooks Store</span>, and be sure to watch the WWDC sessions live streamed and on video throughout the week.  And to read more, visit <a href="http://developer.apple.com/swift">http://developer.apple.com/swift</a></p>]]></content:encoded>
</item>
<item>
<title>Memory Safety: Ensuring Values are Defined Before Use</title>
<link>http://developer.apple.com/swift/blog/?id=28</link>
<guid>http://developer.apple.com/swift/blog/?id=28</guid>
<description>  A primary focus when designing Swift was improving the memory safety of the programming model. There are a lot of aspects of memory safety, so this post will start slow and cover a simple case: how to make sure that variables are initialized with a value before they are used.   The Swift Approach  Variables are considered ‚Äúsafe‚Äù when the developer can be sure that there will be a valid value ready to use before any code tries to access it. Languages take several different approaches to this kind of safety. Some, like C, put the burden entirely on the programmer to employ safe programming techniques ‚Äî a powerful approach, but riddled with risk. C++ and Objective-C improve the situation by enforcing some mandatory patterns, while other languages take extreme measures by requiring initialization at the point of definition.  The primary technique employed by Swift is to use our advanced compiler to perform dataflow analysis of the code. The compiler then enforces that each variable was initialized before it is used, a strategy known as  Definitive Initialization . Languages such as Java and C# (among others) are known to also employ this technique. Swift uses an extended version of this approach for a broad range of variables.  Note: The bottom of this post includes information about other techniques, most of which Swift also employs to some degree.  Definitive Initialization of Local Variables  Swift applies the rules of definitive initialization in many contexts, but the simplest use is for local variables. Definitive initialization gives you more flexibility than a ‚Äúimplicit default initialization‚Äù rule ( see below ) would, because it allows you to write this code:  [view code in blog]  Here the compiler can prove that both sides of the  if  statement are guaranteed to initialize  myInstance , which proves that the method call can‚Äôt use uninitialized memory.  Definitive initialization is a powerful approach, but it is only really useful if it is reliable and predictable. One place that this can lead to surprise is when you have more complex control flow, for example like this:  [view code in blog]  In this case, the compiler will tell you: ‚ÄúVariable  myInstance  used before initialized‚Äù on the call to  printIt() . This is because the compiler does not track the correlation between the predicates in the  if  conditions. While we could teach the compiler to handle individual specific cases like this one, it is impossible to handle all cases (doing so is equivalent to the  halting problem ) so we opted to keep the compiler‚Äôs rules simple and predictable.  Swift makes it extremely easy to initialize a variable. In fact, it is shorter to declare a variable as  var x = 0  giving the variable the initial value  0  than it is to declare the uninitialized variable  var x : Int . Swift favors explicitness of initialization whenever possible. There are also more powerful ways to initialize a variable when the situation calls for it using  init() . For comprehensive information you can read the chapter " Initialization " in The Swift Programming Language.  Other Approaches  In addition to definitive initialization, Swift also employs additional approaches in focused areas of the language. You may have used these techniques in other languages, so we wanted to cover them briefly in this post. Each has some drawbacks, so they aren‚Äôt used as Swift‚Äôs primary approach:   Leave safety to the programmer:  Given the prevalence of C, it was important to understand the pros and cons of simply leaving safety up to the developer. Unfortunately, use of an uninitialized value in C produces  undefined behavior , often leading to runtime explosions. C relies on the programmer to never make a mistake. Given that our goal was to make Swift ‚Äúsafe by default,‚Äù this approach was quickly discarded for general use. However, APIs like  UnsafePointer  allow you to explicitly opt-in to unsafety when this power is absolutely necessary.   Implicit Default Initialization:  Values could be ensured to be safe by having the compiler implicitly initialize them, for example by setting a ‚Äúzero value‚Äù like Objective-C does for instance variables, or by running default initializers like in C++. We explored this approach in depth, but ultimately decided against its broad use because:    This doesn‚Äôt work for cases that have no legal initial value, e.g. protocols with no  init()  requirement, and non-nullable references to classes, which are pervasive in Swift.    Even for primitive types like integers  0  is often the wrong value. That‚Äôs one reason setting the initial value is so easy in Swift. This also makes the code more obvious for those who will maintain it, as well as defining away a potential error of omission, e.g. when  -1  is the right sentinel to use.    Note that default initialization to  nil  is clearly the right answer for nullable values so all values of  Optional  and  ImplicitlyUnwrappedOptional  type automatically initialize to  nil  by default.   Require an initializer at definition.  Put the burden on the developer to always provide an initial value at the time the variable is defined, meaning that  var x : Int  would be illegal without an initializer. While this is a common approach among functional languages, we considered this to be too heavy of a requirement because it enforces a very strict programming style, which gets in the way of expressing natural patterns. </description>
<pubDate>Fri, 24 Apr 2015 12:45:00 PDT</pubDate>
<content:encoded><![CDATA[ <p>A primary focus when designing Swift was improving the memory safety of the programming model. There are a lot of aspects of memory safety, so this post will start slow and cover a simple case: how to make sure that variables are initialized with a value before they are used.</p> <h3>The Swift Approach</h3><p>Variables are considered ‚Äúsafe‚Äù when the developer can be sure that there will be a valid value ready to use before any code tries to access it. Languages take several different approaches to this kind of safety. Some, like C, put the burden entirely on the programmer to employ safe programming techniques ‚Äî a powerful approach, but riddled with risk. C++ and Objective-C improve the situation by enforcing some mandatory patterns, while other languages take extreme measures by requiring initialization at the point of definition.</p><p>The primary technique employed by Swift is to use our advanced compiler to perform dataflow analysis of the code. The compiler then enforces that each variable was initialized before it is used, a strategy known as <a href="http://en.wikipedia.org/wiki/Definite_assignment_analysis">Definitive Initialization</a>. Languages such as Java and C# (among others) are known to also employ this technique. Swift uses an extended version of this approach for a broad range of variables.</p><p class="update">Note: The bottom of this post includes information about other techniques, most of which Swift also employs to some degree.</p><h3>Definitive Initialization of Local Variables</h3><p>Swift applies the rules of definitive initialization in many contexts, but the simplest use is for local variables. Definitive initialization gives you more flexibility than a ‚Äúimplicit default initialization‚Äù rule (<em>see below</em>) would, because it allows you to write this code:</p><a href="http://developer.apple.com/swift/blog/?id=28">[view code in blog]</a><p>Here the compiler can prove that both sides of the <span class="keyword">if</span> statement are guaranteed to initialize <span class="keyword">myInstance</span>, which proves that the method call can‚Äôt use uninitialized memory.</p><p>Definitive initialization is a powerful approach, but it is only really useful if it is reliable and predictable. One place that this can lead to surprise is when you have more complex control flow, for example like this:</p><a href="http://developer.apple.com/swift/blog/?id=28">[view code in blog]</a><p>In this case, the compiler will tell you: ‚ÄúVariable <strong>myInstance</strong> used before initialized‚Äù on the call to <span class="keyword">printIt()</span>. This is because the compiler does not track the correlation between the predicates in the <span class="keyword">if</span> conditions. While we could teach the compiler to handle individual specific cases like this one, it is impossible to handle all cases (doing so is equivalent to the <a href="http://en.wikipedia.org/wiki/Halting_problem">halting problem</a>) so we opted to keep the compiler‚Äôs rules simple and predictable.</p><p>Swift makes it extremely easy to initialize a variable. In fact, it is shorter to declare a variable as <span class="keyword">var x = 0</span> giving the variable the initial value <span class="keyword">0</span> than it is to declare the uninitialized variable <span class="keyword">var x : Int</span>. Swift favors explicitness of initialization whenever possible. There are also more powerful ways to initialize a variable when the situation calls for it using <span class="keyword">init()</span>. For comprehensive information you can read the chapter "<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html">Initialization</a>" in The Swift Programming Language.</p><h3>Other Approaches</h3><p>In addition to definitive initialization, Swift also employs additional approaches in focused areas of the language. You may have used these techniques in other languages, so we wanted to cover them briefly in this post. Each has some drawbacks, so they aren‚Äôt used as Swift‚Äôs primary approach:</p><p><strong>Leave safety to the programmer:</strong> Given the prevalence of C, it was important to understand the pros and cons of simply leaving safety up to the developer. Unfortunately, use of an uninitialized value in C produces <a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html">undefined behavior</a>, often leading to runtime explosions. C relies on the programmer to never make a mistake. Given that our goal was to make Swift ‚Äúsafe by default,‚Äù this approach was quickly discarded for general use. However, APIs like <span class="keyword">UnsafePointer</span> allow you to explicitly opt-in to unsafety when this power is absolutely necessary.</p><p><strong>Implicit Default Initialization:</strong> Values could be ensured to be safe by having the compiler implicitly initialize them, for example by setting a ‚Äúzero value‚Äù like Objective-C does for instance variables, or by running default initializers like in C++. We explored this approach in depth, but ultimately decided against its broad use because:</p><ul><li><p>This doesn‚Äôt work for cases that have no legal initial value, e.g. protocols with no <span class="keyword">init()</span> requirement, and non-nullable references to classes, which are pervasive in Swift.</p></li><li><p>Even for primitive types like integers <span class="keyword">0</span> is often the wrong value. That‚Äôs one reason setting the initial value is so easy in Swift. This also makes the code more obvious for those who will maintain it, as well as defining away a potential error of omission, e.g. when <span class="keyword">-1</span> is the right sentinel to use.</p></li></ul><p>Note that default initialization to <span class="keyword">nil</span> is clearly the right answer for nullable values so all values of <span class="keyword">Optional</span> and <span class="keyword">ImplicitlyUnwrappedOptional</span> type automatically initialize to <span class="keyword">nil</span> by default.</p><p><strong>Require an initializer at definition.</strong> Put the burden on the developer to always provide an initial value at the time the variable is defined, meaning that <span class="keyword">var x : Int</span> would be illegal without an initializer. While this is a common approach among functional languages, we considered this to be too heavy of a requirement because it enforces a very strict programming style, which gets in the way of expressing natural patterns.</p>]]></content:encoded>
</item>
<item>
<title>Increasing Performance by Reducing Dynamic Dispatch</title>
<link>http://developer.apple.com/swift/blog/?id=27</link>
<guid>http://developer.apple.com/swift/blog/?id=27</guid>
<description> Like many other languages, Swift allows a class to override methods and properties declared in its superclasses. This means that the program has to determine at runtime which method or property is being referred to and then perform an indirect call or indirect access. This technique, called  dynamic dispatch , increases language expressivity at the cost of a constant amount of runtime overhead for each indirect usage. In performance sensitive code such overhead is often undesirable. This blog post showcases three ways to improve performance by eliminating such dynamism:  final ,  private , and Whole Module Optimization.  Consider the following example:  [view code in blog]  As written, the compiler will emit a dynamically dispatched call to:   Call  update  on  p .  Call  updatePoint  on  p .  Get the property  point  tuple of p.  Get the property  velocity  of p.   This might not be what you would expect when looking at this code. The dynamic calls are necessary because a subclass of  ParticleModel  might override  point  or  velocity  with a computed property or override  updatePoint()  or  update()  with new implementations.  In Swift, dynamic dispatch calls are implemented by looking up a function from a method table and then performing an indirect call. This is slower than performing a direct call. Additionally, indirect calls also prevent many compiler optimizations, making the indirect call even more expensive. In performance critical code there are techniques you can use to restrict this dynamic behavior when it isn‚Äôt needed to improve performance.  Use  final  when you know that a declaration does not need to be overridden.  The  final  keyword is a restriction on a class, method, or property that indicates that the declaration cannot be overridden. This allows the compiler to safely elide dynamic dispatch indirection. For instance, in the following  point  and  velocity  will be accessed directly through a load from the object‚Äôs stored property and  updatePoint()  will be called via a direct function call. On the other hand,  update()  will still be called via dynamic dispatch, allowing for subclasses to override  update()  with customized functionality.  [view code in blog]  It is possible to mark an entire class as  final  by attaching the attribute to the class itself. This forbids subclassing the class, implying that all functions and properties of the class are  final  as well.  [view code in blog]  Infer  final  on declarations referenced in one file by applying the  private  keyword.  Applying the  private  keyword to a declaration restricts the visibility of the declaration to the current file. This allows the compiler to find all potentially overriding declarations. The absence of any such overriding declarations enables the compiler to infer the  final  keyword automatically and remove indirect calls for methods and property accesses.  Assuming there is no class overriding  ParticleModel  in the current file, the compiler can replace all dynamically dispatched calls to private declarations with direct calls.  [view code in blog]  As in the previous example,  point  and  velocity  are accessed directly and  updatePoint()  is called directly. Again,  update()  will be invoked indirectly due to  update()  not being  private .  Just like with  final , it is possible to apply the  private  attribute to the class declaration itself causing the class to be  private  and thus all of the properties and methods of the class as well.  [view code in blog]  Use Whole Module Optimization to infer  final  on  internal  declarations.  Declarations with  internal  access (the default if nothing is declared) are only visible within the module where they are declared. Because Swift normally compiles the files that make up a module separately, the compiler cannot ascertain whether or not an  internal  declaration is overridden in a different file. However, if Whole Module Optimization is enabled, all of the module is compiled together at the same time. This allows the compiler to make inferences about the entire module together and infer  final  on declarations with  internal  if there are no visible overrides.  Let‚Äôs go back to the original code snippet, this time adding some extra  public  keywords to  ParticleModel .  [view code in blog]  When compiling this snippet with Whole Module Optimization the compiler can infer  final  on the properties  point ,  velocity , and the method call  updatePoint() . In contrast, it can not be inferred that  update()  is  final  since  update()  has public access. </description>
<pubDate>Thu, 09 Apr 2015 09:30:00 PDT</pubDate>
<content:encoded><![CDATA[<p>Like many other languages, Swift allows a class to override methods and properties declared in its superclasses. This means that the program has to determine at runtime which method or property is being referred to and then perform an indirect call or indirect access. This technique, called <em>dynamic dispatch</em>, increases language expressivity at the cost of a constant amount of runtime overhead for each indirect usage. In performance sensitive code such overhead is often undesirable. This blog post showcases three ways to improve performance by eliminating such dynamism: <span class="keyword">final</span>, <span class="keyword">private</span>, and Whole Module Optimization.</p><p>Consider the following example:</p><a href="http://developer.apple.com/swift/blog/?id=27">[view code in blog]</a><p>As written, the compiler will emit a dynamically dispatched call to:</p><ol><li>Call <span class="keyword">update</span> on <span class="keyword">p</span>.</li><li>Call <span class="keyword">updatePoint</span> on <span class="keyword">p</span>.</li><li>Get the property <span class="keyword">point</span> tuple of p.</li><li>Get the property <span class="keyword">velocity</span> of p.</li></ol><p>This might not be what you would expect when looking at this code. The dynamic calls are necessary because a subclass of <span class="keyword">ParticleModel</span> might override <span class="keyword">point</span> or <span class="keyword">velocity</span> with a computed property or override <span class="keyword">updatePoint()</span> or <span class="keyword">update()</span> with new implementations.</p><p>In Swift, dynamic dispatch calls are implemented by looking up a function from a method table and then performing an indirect call. This is slower than performing a direct call. Additionally, indirect calls also prevent many compiler optimizations, making the indirect call even more expensive. In performance critical code there are techniques you can use to restrict this dynamic behavior when it isn‚Äôt needed to improve performance.</p><h3>Use <span class="menlo">final</span> when you know that a declaration does not need to be overridden.</h3><p>The <span class="keyword">final</span> keyword is a restriction on a class, method, or property that indicates that the declaration cannot be overridden. This allows the compiler to safely elide dynamic dispatch indirection. For instance, in the following <span class="keyword">point</span> and <span class="keyword">velocity</span> will be accessed directly through a load from the object‚Äôs stored property and <span class="keyword">updatePoint()</span> will be called via a direct function call. On the other hand, <span class="keyword">update()</span> will still be called via dynamic dispatch, allowing for subclasses to override <span class="keyword">update()</span> with customized functionality.</p><a href="http://developer.apple.com/swift/blog/?id=27">[view code in blog]</a><p>It is possible to mark an entire class as <span class="keyword">final</span> by attaching the attribute to the class itself. This forbids subclassing the class, implying that all functions and properties of the class are <span class="keyword">final</span> as well.</p><a href="http://developer.apple.com/swift/blog/?id=27">[view code in blog]</a><h3>Infer <span class="menlo">final</span> on declarations referenced in one file by applying the <span class="menlo">private</span> keyword.</h3><p>Applying the <span class="keyword">private</span> keyword to a declaration restricts the visibility of the declaration to the current file. This allows the compiler to find all potentially overriding declarations. The absence of any such overriding declarations enables the compiler to infer the <span class="keyword">final</span> keyword automatically and remove indirect calls for methods and property accesses.</p><p>Assuming there is no class overriding <span class="keyword">ParticleModel</span> in the current file, the compiler can replace all dynamically dispatched calls to private declarations with direct calls.</p><a href="http://developer.apple.com/swift/blog/?id=27">[view code in blog]</a><p>As in the previous example, <span class="keyword">point</span> and <span class="keyword">velocity</span> are accessed directly and <span class="keyword">updatePoint()</span> is called directly. Again, <span class="keyword">update()</span> will be invoked indirectly due to <span class="keyword">update()</span> not being <span class="keyword">private</span>.</p><p>Just like with <span class="keyword">final</span>, it is possible to apply the <span class="keyword">private</span> attribute to the class declaration itself causing the class to be <span class="keyword">private</span> and thus all of the properties and methods of the class as well.</p><a href="http://developer.apple.com/swift/blog/?id=27">[view code in blog]</a><h3>Use Whole Module Optimization to infer <span class="menlo">final</span> on <span class="menlo">internal</span> declarations.</h3><p>Declarations with <span class="keyword">internal</span> access (the default if nothing is declared) are only visible within the module where they are declared. Because Swift normally compiles the files that make up a module separately, the compiler cannot ascertain whether or not an <span class="keyword">internal</span> declaration is overridden in a different file. However, if Whole Module Optimization is enabled, all of the module is compiled together at the same time. This allows the compiler to make inferences about the entire module together and infer <span class="keyword">final</span> on declarations with <span class="keyword">internal</span> if there are no visible overrides.</p><p>Let‚Äôs go back to the original code snippet, this time adding some extra <span class="keyword">public</span> keywords to <span class="keyword">ParticleModel</span>.</p><a href="http://developer.apple.com/swift/blog/?id=27">[view code in blog]</a><p>When compiling this snippet with Whole Module Optimization the compiler can infer <span class="keyword">final</span> on the properties <span class="keyword">point</span>, <span class="keyword">velocity</span>, and the method call <span class="keyword">updatePoint()</span>. In contrast, it can not be inferred that <span class="keyword">update()</span> is <span class="keyword">final</span> since <span class="keyword">update()</span> has public access.</p>]]></content:encoded>
</item>
<item>
<title>New Playgrounds Part 2 - Sources</title>
<link>http://developer.apple.com/swift/blog/?id=26</link>
<guid>http://developer.apple.com/swift/blog/?id=26</guid>
<description> Xcode 6.3 beta 3 adds even more to the new playgrounds format introduced in the last beta. The Xcode Project Navigator now lets you easily access a new Sources folder that includes additional Swift code, as well as the Resources folder.  Playgrounds and the Project Navigator  Playgrounds are now represented within Xcode as a bundle with a disclosure triangle that reveals Resources and Sources folders when clicked. These folders contain additional content that is easily accessible from your playground‚Äôs main Swift code. To see these folders, choose View > Navigators > Show Project Navigator (or just hit Command-1).  It is easy to drag-and-drop images and other content into the Resources folder. You may want to go back and look at the DemoNewFormat.playground file from the  previous blog post  for another example of how these resources are stored and used (using the latest Xcode 6.3 beta 3).  Sources Folder  The Sources folder is new in Xcode 6.3 beta 3. This folder contains additional Swift source files that your main playground code can easily access. Putting extra supporting  .swift  files into the Sources folder makes it easy to keep your playground clean and readable. Code in the Sources folder also gains a big performance benefit because this code is compiled once, and is not run in the same interactive manner as the main playground code. This allows curriculum and sample code authors to create even more interactive and exciting playgrounds while the visible code remains approachable for the reader.  Mandelbrot Example  Here‚Äôs an example playground that calculates the complex and beautiful Mandelbrot set. This playground uses the Sources folder to demonstrate the power and added performance that it enables. To see the inner workings of  this playground , examine the code within the Sources folder.    </description>
<pubDate>Tue, 17 Mar 2015 15:10:00 PDT</pubDate>
<content:encoded><![CDATA[<p>Xcode 6.3 beta 3 adds even more to the new playgrounds format introduced in the last beta. The Xcode Project Navigator now lets you easily access a new Sources folder that includes additional Swift code, as well as the Resources folder.</p><h3>Playgrounds and the Project Navigator</h3><p>Playgrounds are now represented within Xcode as a bundle with a disclosure triangle that reveals Resources and Sources folders when clicked. These folders contain additional content that is easily accessible from your playground‚Äôs main Swift code. To see these folders, choose View > Navigators > Show Project Navigator (or just hit Command-1).</p><p>It is easy to drag-and-drop images and other content into the Resources folder. You may want to go back and look at the DemoNewFormat.playground file from the <a href="https://developer.apple.com/swift/blog/?id=24">previous blog post</a> for another example of how these resources are stored and used (using the latest Xcode 6.3 beta 3).</p><h3>Sources Folder</h3><p>The Sources folder is new in Xcode 6.3 beta 3. This folder contains additional Swift source files that your main playground code can easily access. Putting extra supporting <em>.swift</em> files into the Sources folder makes it easy to keep your playground clean and readable. Code in the Sources folder also gains a big performance benefit because this code is compiled once, and is not run in the same interactive manner as the main playground code. This allows curriculum and sample code authors to create even more interactive and exciting playgrounds while the visible code remains approachable for the reader.</p><h3>Mandelbrot Example</h3><p>Here‚Äôs an example playground that calculates the complex and beautiful Mandelbrot set. This playground uses the Sources folder to demonstrate the power and added performance that it enables. To see the inner workings of <a href="http://developer.apple.com/swift/blog/downloads/Mandelbrot.zip">this playground</a>, examine the code within the Sources folder.</p><p><img alt="Mandlebrot Screenshot" src="https://devimages.apple.com.edgekey.net/swift/blog/images/mandelbrot-screen.png" width="800" height="1274" /></p>]]></content:encoded>
</item>
<item>
<title>Nullability and Objective-C</title>
<link>http://developer.apple.com/swift/blog/?id=25</link>
<guid>http://developer.apple.com/swift/blog/?id=25</guid>
<description> UPDATE: This post was updated to use the new _Nullable syntax in Xcode 7.  One of the great things about Swift is that it transparently interoperates with Objective-C code, both existing frameworks written in Objective-C and code in your app. However, in Swift there‚Äôs a strong distinction between optional and non-optional references, e.g.  NSView  vs.  NSView? , while Objective-C represents boths of these two types as  NSView * . Because the Swift compiler can‚Äôt be sure whether a particular  NSView *  is optional or not, the type is brought into Swift as an implicitly unwrapped optional,  NSView! .  In previous Xcode releases, some Apple frameworks had been specially audited so that their API would show up with proper Swift optionals. Xcode 6.3 supports this for your own code with a new Objective-C language feature:  nullability annotations .  The Core:  _Nullable  and  _Nonnull   At the core of this feature we have two new type annotations:  _Nullable  and  _Nonnull . As you might expect, a  _Nullable  pointer may have a  NULL  or  nil  value, while a  _Nonnull  one should not. The compiler will tell you if you try to break the rules.  [view code in blog]  You can use  _Nullable  and  _Nonnull  almost anywhere you can use the normal C  const  keyword, though of course they have to apply to a pointer type. However, in the common case there‚Äôs a much nicer way to write these annotations: within method declarations you can use the non-underscored forms  nullable  and  nonnull  immediately after an open parenthesis, as long as the type is a simple object or block pointer.  [view code in blog]  And for properties, you can use the same non-underscored spelling by moving the annotation into the property attributes list.  [view code in blog]  The non-underscored forms are nicer than the underscored ones, but you‚Äôd still need to apply them to every type in your header. To make that job easier and to make your headers clearer, you‚Äôll want to use audited regions.  Audited Regions  To ease adoption of the new annotations, you can mark certain regions of your Objective-C header files as  audited for nullability . Within these regions, any simple pointer type will be assumed to be  nonnull . This collapses our earlier example down into something much simpler.  [view code in blog]  For safety, there are a few exceptions to this rule:    typedef  types don‚Äôt usually have an inherent nullability‚Äîthey can easily be either nullable or non-nullable depending on the context. Therefore,  typedef  types are not assumed to be  nonnull , even within audited regions.  More complex pointer types like  id *  must be explicitly annotated. For example, to specify a non-nullable pointer to a nullable object reference, use  _Nullable id * _Nonnull .  The particular type  NSError **  is so often used to return errors via method parameters that it is always assumed to be a nullable pointer to a nullable  NSError  reference.   You can read more about this in the  Error Handling Programming Guide .  Compatibility  What if your Objective-C framework has existing code written against it? Is it safe to just change your types like this?  Yes, it is .   Existing compiled code that uses your framework will continue to work, i.e. the ABI does not change. This also means that existing code will not catch incorrect passing of  nil  at runtime.  Existing  source  code that uses your framework may get additional warnings for current uses of unsafe behavior at compile time when you move to the new Swift compiler.   nonnull  does not affect optimization. In particular, you can still check parameters marked  nonnull  to see if they are actually  nil  at runtime. This may be necessary for backwards-compatibility.   In general, you should look at  nullable  and  nonnull  roughly the way you currently use assertions or exceptions: violating the contract is a programmer error. In particular, return values are something you control, so you should never return  nil  for a non-nullable return type unless it is for backwards-compatibility.  This feature was first released in Xcode 6.3 with the keywords  __nullable  and  __nonnull . Due to potential conflicts with third-party libraries, we‚Äôve changed them in Xcode 7 to the _Nullable and _Nonnull you see here. However, for compatibility with Xcode 6.3 we‚Äôve predefined macros  __nullable  and  __nonnull  to expand to the new names.  Back to Swift  Now that we‚Äôve added nullability annotations to our Objective-C header, let‚Äôs use it from Swift:  Before annotating our Objective-C:  [view code in blog]  After annotations:  [view code in blog]  The Swift code is now cleaner. It‚Äôs a subtle change, but it will make using your framework more pleasant.  Nullability annotations for C and Objective-C are available starting in Xcode 6.3. For more information, see the  Xcode 6.3 Release Notes . </description>
<pubDate>Thu, 12 Mar 2015 13:00:00 PDT</pubDate>
<content:encoded><![CDATA[<p class="update">UPDATE: This post was updated to use the new _Nullable syntax in Xcode 7.</p><p>One of the great things about Swift is that it transparently interoperates with Objective-C code, both existing frameworks written in Objective-C and code in your app. However, in Swift there‚Äôs a strong distinction between optional and non-optional references, e.g. <span class="keyword">NSView</span> vs. <span class="keyword">NSView?</span>, while Objective-C represents boths of these two types as <span class="keyword">NSView *</span>. Because the Swift compiler can‚Äôt be sure whether a particular <span class="keyword">NSView *</span> is optional or not, the type is brought into Swift as an implicitly unwrapped optional, <span class="keyword">NSView!</span>.</p><p>In previous Xcode releases, some Apple frameworks had been specially audited so that their API would show up with proper Swift optionals. Xcode 6.3 supports this for your own code with a new Objective-C language feature: <em>nullability annotations</em>.</p><h3>The Core: <span class="menlo">_Nullable</span> and <span class="menlo">_Nonnull</span></h3><p>At the core of this feature we have two new type annotations: <span class="keyword">_Nullable</span> and <span class="keyword">_Nonnull</span>. As you might expect, a <span class="keyword">_Nullable</span> pointer may have a <span class="keyword">NULL</span> or <span class="keyword">nil</span> value, while a <span class="keyword">_Nonnull</span> one should not. The compiler will tell you if you try to break the rules.</p><a href="http://developer.apple.com/swift/blog/?id=25">[view code in blog]</a><p>You can use <span class="keyword">_Nullable</span> and <span class="keyword">_Nonnull</span> almost anywhere you can use the normal C <span class="keyword">const</span> keyword, though of course they have to apply to a pointer type. However, in the common case there‚Äôs a much nicer way to write these annotations: within method declarations you can use the non-underscored forms <span class="keyword">nullable</span> and <span class="keyword">nonnull</span> immediately after an open parenthesis, as long as the type is a simple object or block pointer.</p><a href="http://developer.apple.com/swift/blog/?id=25">[view code in blog]</a><p>And for properties, you can use the same non-underscored spelling by moving the annotation into the property attributes list.</p><a href="http://developer.apple.com/swift/blog/?id=25">[view code in blog]</a><p>The non-underscored forms are nicer than the underscored ones, but you‚Äôd still need to apply them to every type in your header. To make that job easier and to make your headers clearer, you‚Äôll want to use audited regions.</p><h3>Audited Regions</h3><p>To ease adoption of the new annotations, you can mark certain regions of your Objective-C header files as <em>audited for nullability</em>. Within these regions, any simple pointer type will be assumed to be <span class="keyword">nonnull</span>. This collapses our earlier example down into something much simpler.</p><a href="http://developer.apple.com/swift/blog/?id=25">[view code in blog]</a><p>For safety, there are a few exceptions to this rule:</p><ul><li><span class="keyword">typedef</span> types don‚Äôt usually have an inherent nullability‚Äîthey can easily be either nullable or non-nullable depending on the context. Therefore, <span class="keyword">typedef</span> types are not assumed to be <span class="keyword">nonnull</span>, even within audited regions.</li><li>More complex pointer types like <span class="keyword">id *</span> must be explicitly annotated. For example, to specify a non-nullable pointer to a nullable object reference, use <span class="keyword">_Nullable id * _Nonnull</span>.</li><li>The particular type <span class="keyword">NSError **</span> is so often used to return errors via method parameters that it is always assumed to be a nullable pointer to a nullable <span class="keyword">NSError</span> reference.</li></ul><p>You can read more about this in the <a href="http://developer.apple.com/go/?id=error-handling-cocoa">Error Handling Programming Guide</a>.</p><h3>Compatibility</h3><p>What if your Objective-C framework has existing code written against it? Is it safe to just change your types like this? <em>Yes, it is</em>.</p><ul><li>Existing compiled code that uses your framework will continue to work, i.e. the ABI does not change. This also means that existing code will not catch incorrect passing of <span class="keyword">nil</span> at runtime.</li><li>Existing <em>source</em> code that uses your framework may get additional warnings for current uses of unsafe behavior at compile time when you move to the new Swift compiler.</li><li><span class="keyword">nonnull</span> does not affect optimization. In particular, you can still check parameters marked <span class="keyword">nonnull</span> to see if they are actually <span class="keyword">nil</span> at runtime. This may be necessary for backwards-compatibility.</li></ul><p>In general, you should look at <span class="keyword">nullable</span> and <span class="keyword">nonnull</span> roughly the way you currently use assertions or exceptions: violating the contract is a programmer error. In particular, return values are something you control, so you should never return <span class="keyword">nil</span> for a non-nullable return type unless it is for backwards-compatibility.</p><p>This feature was first released in Xcode 6.3 with the keywords <span class="keyword">__nullable</span> and <span class="keyword">__nonnull</span>. Due to potential conflicts with third-party libraries, we‚Äôve changed them in Xcode 7 to the _Nullable and _Nonnull you see here. However, for compatibility with Xcode 6.3 we‚Äôve predefined macros <span class="keyword">__nullable</span> and <span class="keyword">__nonnull</span> to expand to the new names.</p><h3>Back to Swift</h3><p>Now that we‚Äôve added nullability annotations to our Objective-C header, let‚Äôs use it from Swift:</p><p>Before annotating our Objective-C:</p><a href="http://developer.apple.com/swift/blog/?id=25">[view code in blog]</a><p>After annotations:</p><a href="http://developer.apple.com/swift/blog/?id=25">[view code in blog]</a><p>The Swift code is now cleaner. It‚Äôs a subtle change, but it will make using your framework more pleasant.</p><p>Nullability annotations for C and Objective-C are available starting in Xcode 6.3. For more information, see the <a href="http://developer.apple.com/go/?id=xcode-6.3-beta-release-notes">Xcode 6.3 Release Notes</a>.</p>]]></content:encoded>
</item>
<item>
<title>New Playgrounds</title>
<link>http://developer.apple.com/swift/blog/?id=24</link>
<guid>http://developer.apple.com/swift/blog/?id=24</guid>
<description> Xcode 6.3 beta 2 includes significant improvements to Swift playgrounds, with great features for authors. It‚Äôs now even easier to create rich, interactive playgrounds ‚Äî perfect for documentation, tutorials, or samples to include with your projects.  The new playgrounds are especially useful for educators. You can insert rich instructional content with paragraph headings, diagrams, and links to additional material alongside the interactive Swift code.  New features in Xcode 6.3 playgrounds include the following:    Inline results  display the output of your Swift code within the main editor window. The results area can be resized and configured to show different views of the output.   Stylized text  is easy to add to your playground by adding special markup to your comments based on the familiar Markdown syntax. Some available styles are headings, bold, italic, lists, bullets, and links to external or bundled resources.   The Resources folder  bundles images and other content directly within the playground. These resources can be accessed from your Swift code or from the rich comments within the playground.  (Note: with Xcode 6.3 beta 2 use Show Package Contents in Finder to drag files into the playground‚Äôs Resources folder.)     The latest Xcode 6.3 beta  includes the new playgrounds authoring features. These features are still evolving, so be sure to read the  release notes  and  let us know  of any bugs you find.  Here is a demonstration playground  to get you started.  </description>
<pubDate>Tue, 24 Feb 2015 15:00:00 PST</pubDate>
<content:encoded><![CDATA[<p>Xcode 6.3 beta 2 includes significant improvements to Swift playgrounds, with great features for authors. It‚Äôs now even easier to create rich, interactive playgrounds ‚Äî perfect for documentation, tutorials, or samples to include with your projects.</p><p>The new playgrounds are especially useful for educators. You can insert rich instructional content with paragraph headings, diagrams, and links to additional material alongside the interactive Swift code.</p><p>New features in Xcode 6.3 playgrounds include the following:</p><ul><li><strong>Inline results</strong> display the output of your Swift code within the main editor window. The results area can be resized and configured to show different views of the output.</li><li><strong>Stylized text</strong> is easy to add to your playground by adding special markup to your comments based on the familiar Markdown syntax. Some available styles are headings, bold, italic, lists, bullets, and links to external or bundled resources.</li><li><strong>The Resources folder</strong> bundles images and other content directly within the playground. These resources can be accessed from your Swift code or from the rich comments within the playground. <em>(Note: with Xcode 6.3 beta 2 use Show Package Contents in Finder to drag files into the playground‚Äôs Resources folder.)</em></li></ul><p><a href="http://developer.apple.com/xcode/downloads/">The latest Xcode 6.3 beta</a> includes the new playgrounds authoring features. These features are still evolving, so be sure to read the <a href="https://developer.apple.com/devcenter/download.action?path=/Developer_Tools/Xcode_6.3_beta_2/Xcode_6.3_beta_2_Release_Notes.pdf">release notes</a> and <a href="https://bugreport.apple.com/">let us know</a> of any bugs you find. <a href="http://developer.apple.com/swift/blog/downloads/DemoNewFormat.zip">Here is a demonstration playground</a> to get you started.</p><img alt="Demo New Format Screenshot" src="https://devimages.apple.com.edgekey.net/swift/blog/images/DemoNewFormat.png" width="800" height="1334" />]]></content:encoded>
</item>
<item>
<title>The  as!  Operator</title>
<link>http://developer.apple.com/swift/blog/?id=23</link>
<guid>http://developer.apple.com/swift/blog/?id=23</guid>
<description> Prior to Swift 1.2, the  as  operator could be used to carry out two different kinds of conversion, depending on the type of expression being converted and the type it was being converted to:    Guaranteed conversion  of a value of one type to another, whose success can be verified by the Swift compiler. For example, upcasting (i.e., converting from a class to one of its superclasses) or specifying the type of a literal expression, (e.g.,  1 as Float ).   Forced conversion  of one value to another, whose safety cannot be guaranteed by the Swift compiler and which may cause a runtime trap. For example downcasting, converting from a class to one of its subclasses.   Swift 1.2 separates the notions of guaranteed conversion and forced conversion into two distinct operators. Guaranteed conversion is still performed with the  as  operator, but forced conversion now uses the  as!  operator. The  !  is meant to indicate that the conversion may fail. This way, you know at a glance which conversions may cause the program to crash.  The following example illustrates the change:  [view code in blog]  Note the analogy between the expression postfix operators  !  and  ?  and the conversion operators  as!  and  as? :  [view code in blog]  It may be easiest to remember the pattern for these operators in Swift as:  !  implies  ‚Äúthis might trap,‚Äù  while  ?  indicates  ‚Äúthis might be nil.‚Äù  </description>
<pubDate>Wed, 18 Feb 2015 15:00:00 PST</pubDate>
<content:encoded><![CDATA[<p>Prior to Swift 1.2, the <span class="keyword">as</span> operator could be used to carry out two different kinds of conversion, depending on the type of expression being converted and the type it was being converted to:</p><ul><li><strong>Guaranteed conversion</strong> of a value of one type to another, whose success can be verified by the Swift compiler. For example, upcasting (i.e., converting from a class to one of its superclasses) or specifying the type of a literal expression, (e.g., <span class="keyword">1 as Float</span>).</li><li><strong>Forced conversion</strong> of one value to another, whose safety cannot be guaranteed by the Swift compiler and which may cause a runtime trap. For example downcasting, converting from a class to one of its subclasses.</li></ul><p>Swift 1.2 separates the notions of guaranteed conversion and forced conversion into two distinct operators. Guaranteed conversion is still performed with the <span class="keyword">as</span> operator, but forced conversion now uses the <span class="keyword">as!</span> operator. The <span class="keyword">!</span> is meant to indicate that the conversion may fail. This way, you know at a glance which conversions may cause the program to crash.</p><p>The following example illustrates the change:</p><a href="http://developer.apple.com/swift/blog/?id=23">[view code in blog]</a><p>Note the analogy between the expression postfix operators <span class="keyword">!</span> and <span class="keyword">?</span> and the conversion operators <span class="keyword">as!</span> and <span class="keyword">as?</span>:</p><a href="http://developer.apple.com/swift/blog/?id=23">[view code in blog]</a><p>It may be easiest to remember the pattern for these operators in Swift as: <span class="keyword">!</span> implies <em>‚Äúthis might trap,‚Äù</em> while <span class="keyword">?</span> indicates <em>‚Äúthis might be nil.‚Äù</em></p>]]></content:encoded>
</item>
<item>
<title>Swift 1.2 and Xcode 6.3 beta</title>
<link>http://developer.apple.com/swift/blog/?id=22</link>
<guid>http://developer.apple.com/swift/blog/?id=22</guid>
<description> Today Swift 1.2 was released as part of Xcode 6.3 beta. This beta release includes a significantly enhanced Swift compiler, as well as new features in the Swift language itself. For the complete list of changes, read the  release notes . This blog post will focus on the highlights.  Compiler improvements  The Swift 1.2 compiler was engineered to be more stable and to improve performance in every way. These changes also provide a better experience when working with Swift in Xcode. Some of the most visible improvements include:    Incremental builds  ‚Äî Source files that haven‚Äôt changed will no longer be re-compiled by default, which will significantly improve build times for most common cases. Larger structural changes to your code may still require multiple files to be rebuilt.   Faster executables  ‚Äî Debug builds produce binaries that run considerably faster, and new optimizations deliver even better Release build performance.   Better compiler diagnostics  ‚Äî Clearer error and warning messages, along with new Fix-its, make it easier to write proper Swift 1.2 code.   Stability improvements  ‚Äî The most common compiler crashes have been fixed. You should also see fewer SourceKit warnings within the Xcode editor.   New language features  In Swift 1.2, the language has been further refined to ensure safe, predictable behavior. We also continue to improve the interaction between Swift and Objective-C. Some of the more notable changes include:     as!  for failable casts  ‚Äî Casts that can fail at runtime are now expressed with the new  as!  operator to make their potential for runtime failure clear to readers and maintainers of your code.   Nullability may now be expressed in Objective-C headers  ‚Äî New Objective-C extensions in Clang allow you to express the nullability of pointers and blocks in your Objective-C API. You can provide Objective-C frameworks that work great with Swift code, and improve your Swift experience when mixing and matching with Objective-C code in your own project.   Swift enums can now be exported to Objective-C using the  @objc  attribute  ‚Äî For example, the following Swift code:   [view code in blog]  imports into Objective-C as:  [view code in blog]     let  constants are now more powerful and consistent  ‚Äî The new rule is that a  let  constant must be initialized before use (like a  var ), and that it may only be initialized, not reassigned or mutated after initialization.   This enables patterns like:  [view code in blog]  This formerly required the use of a  var  even though there is no mutation taking place. Properties have been folded into this model to simplify their semantics in initializers as well.    More powerful optional unwrapping with  if let   ‚Äî The  if let  construct can now unwrap multiple optionals at once, as well as include intervening boolean conditions. This lets you express conditional control flow without unnecessary nesting.   New native Set data structure  ‚Äî An unordered collection of unique elements that bridges with  NSSet  and provides value semantics like  Array  and  Dictionary .   Conclusion  We appreciate all of the bugs you have filed, and expect that many of the most common issues have been fixed in this beta. Swift 1.2 is a major step forward for both the language and the tools. It does include some source-incompatible changes that require updates to your code, so Xcode 6.3 includes a migrator to help automate the process. To begin the migration, click the Edit menu, then choose Convert > To Swift 1.2... </description>
<pubDate>Mon, 09 Feb 2015 11:00:00 PST</pubDate>
<content:encoded><![CDATA[<p>Today Swift 1.2 was released as part of Xcode 6.3 beta. This beta release includes a significantly enhanced Swift compiler, as well as new features in the Swift language itself. For the complete list of changes, read the <a href="https://developer.apple.com/devcenter/download.action?path=/Developer_Tools/Xcode_6.3_beta/Xcode_6.3_beta_Release_Notes.pdf">release notes</a>. This blog post will focus on the highlights.</p><h3>Compiler improvements</h3><p>The Swift 1.2 compiler was engineered to be more stable and to improve performance in every way. These changes also provide a better experience when working with Swift in Xcode. Some of the most visible improvements include:</p><ul><li><strong>Incremental builds</strong> ‚Äî Source files that haven‚Äôt changed will no longer be re-compiled by default, which will significantly improve build times for most common cases. Larger structural changes to your code may still require multiple files to be rebuilt.</li><li><strong>Faster executables</strong> ‚Äî Debug builds produce binaries that run considerably faster, and new optimizations deliver even better Release build performance.</li><li><strong>Better compiler diagnostics</strong> ‚Äî Clearer error and warning messages, along with new Fix-its, make it easier to write proper Swift 1.2 code.</li><li><strong>Stability improvements</strong> ‚Äî The most common compiler crashes have been fixed. You should also see fewer SourceKit warnings within the Xcode editor.</li></ul><h3>New language features</h3><p>In Swift 1.2, the language has been further refined to ensure safe, predictable behavior. We also continue to improve the interaction between Swift and Objective-C. Some of the more notable changes include:</p><ul><li><strong><span class="keyword">as!</span> for failable casts</strong> ‚Äî Casts that can fail at runtime are now expressed with the new <span class="keyword">as!</span> operator to make their potential for runtime failure clear to readers and maintainers of your code.</li><li><strong>Nullability may now be expressed in Objective-C headers</strong> ‚Äî New Objective-C extensions in Clang allow you to express the nullability of pointers and blocks in your Objective-C API. You can provide Objective-C frameworks that work great with Swift code, and improve your Swift experience when mixing and matching with Objective-C code in your own project.</li><li><strong>Swift enums can now be exported to Objective-C using the <span class="keyword">@objc</span> attribute</strong> ‚Äî For example, the following Swift code:</li></ul><a href="http://developer.apple.com/swift/blog/?id=22">[view code in blog]</a><p>imports into Objective-C as:</p><a href="http://developer.apple.com/swift/blog/?id=22">[view code in blog]</a><ul><li><strong><span class="keyword">let</span> constants are now more powerful and consistent</strong> ‚Äî The new rule is that a <span class="keyword">let</span> constant must be initialized before use (like a <span class="keyword">var</span>), and that it may only be initialized, not reassigned or mutated after initialization.</li></ul><p>This enables patterns like:</p><a href="http://developer.apple.com/swift/blog/?id=22">[view code in blog]</a><p>This formerly required the use of a <span class="keyword">var</span> even though there is no mutation taking place. Properties have been folded into this model to simplify their semantics in initializers as well.</p><ul><li><strong>More powerful optional unwrapping with <span class="keyword">if let</span></strong> ‚Äî The <span class="keyword">if let</span> construct can now unwrap multiple optionals at once, as well as include intervening boolean conditions. This lets you express conditional control flow without unnecessary nesting.</li><li><strong>New native Set data structure</strong> ‚Äî An unordered collection of unique elements that bridges with <span class="keyword">NSSet</span> and provides value semantics like <span class="keyword">Array</span> and <span class="keyword">Dictionary</span>.</li></ul><h3>Conclusion</h3><p>We appreciate all of the bugs you have filed, and expect that many of the most common issues have been fixed in this beta. Swift 1.2 is a major step forward for both the language and the tools. It does include some source-incompatible changes that require updates to your code, so Xcode 6.3 includes a migrator to help automate the process. To begin the migration, click the Edit menu, then choose Convert > To Swift 1.2...</p>]]></content:encoded>
</item>
<item>
<title>New Swift Development Courses Available on iTunes U</title>
<link>http://developer.apple.com/swift/blog/?id=21</link>
<guid>http://developer.apple.com/swift/blog/?id=21</guid>
<description> iTunes U is the world‚Äôs largest online catalog of free educational content from top schools and prominent organizations. Thousands of educational institutions are hosting public and private courses encompassing the arts, sciences, health and medicine, education, business, software development and more. These courses offer the same curriculum as the on-campus class, and often include lecture videos.  Stanford University has one of the most popular iOS development courses on iTunes U, which has been downloaded over 1.2 million times.  Now this course has been updated to use Swift. The first two lectures from the new  ‚ÄúDeveloping iOS 8 Apps with Swift‚Äù   class are now live and additional lessons will be added as they are taught.  Swift courses from other internationally recognized universities, such as  Plymouth University  in the UK, are also available on iTunes U with courses from other top educational institutions coming soon. </description>
<pubDate>Wed, 28 Jan 2015 16:05:00 PST</pubDate>
<content:encoded><![CDATA[<p>iTunes U is the world‚Äôs largest online catalog of free educational content from top schools and prominent organizations. Thousands of educational institutions are hosting public and private courses encompassing the arts, sciences, health and medicine, education, business, software development and more. These courses offer the same curriculum as the on-campus class, and often include lecture videos.</p><p>Stanford University has one of the most popular iOS development courses on iTunes U, which has been downloaded over 1.2 million times.  Now this course has been updated to use Swift. The first two lectures from the new <a href="http://itunes.com/StanfordSwift">‚ÄúDeveloping iOS 8 Apps with Swift‚Äù</a>  class are now live and additional lessons will be added as they are taught.  Swift courses from other internationally recognized universities, such as <a href="http://itunes.com/PlymouthSwift">Plymouth University</a> in the UK, are also available on iTunes U with courses from other top educational institutions coming soon.</p>]]></content:encoded>
</item>
<item>
<title>Redefining Everything with the Swift REPL</title>
<link>http://developer.apple.com/swift/blog/?id=20</link>
<guid>http://developer.apple.com/swift/blog/?id=20</guid>
<description> Our  first entry on the REPL  covered just the basics, showing how to use the REPL to experiment with Swift as you learn the language. This post explores one way that the REPL bends normal coding rules to give you new powers when developing.  Redefining Identifiers  The Swift compiler automatically protects against a wide range of programming mistakes, including unintentional ambiguity arising from defining the same identifier twice:  [view code in blog]  This makes sense when coding in a non-interactive editor, but in the REPL interactive environment it‚Äôs useful to be able to easily make changes. The REPL was specifically designed with this kind of convenience in mind:  [view code in blog]  The newer definition replaces the existing definition for all subsequent references. As illustrated above, even the type of the definition can be changed in the process. This allows a wide range of experiments through iterative refinement. For example, you can start out with a recursive implementation of a function:  [view code in blog]  This is just one way to write this function. You can experiment with your code, trying out different algorithms and APIs. The REPL makes it easy to define a new and improved implementation:  [view code in blog]  Typing the same expression in the REPL now executes the new implementation. This is a simple example, but it illustrates the iterative experimentation that the REPL was designed to facilitate.  Redefinition or Overload?  Redefining constants, variables, and types all work intuitively, and, as we can see above, it is also possible to redefine functions. This raises an obvious question: how does this interact with function overloading? The REPL only replaces an existing definition when it has the same name and signature as shown in the Fibonacci example above. If a function with the same name but a distinct signature already exists, it just defines a new overload. Keep in mind that Swift allows function overloading even when two signatures differ only in their return type. For example:  [view code in blog]  The above declarations define two distinct functions that must be called in a manner where only one of the available overloads can be inferred as returning a compatible type:  [view code in blog]  Capturing Definitions  The ability to redefine an identifier is powerful, but it only applies to subsequent uses of the identifier. Any line of code that has already been compiled by the REPL retains its reference to the previous definition. It‚Äôs as if the new definition obscures the old one but doesn‚Äôt eliminate it entirely. The following illustrates how this works in practice:  [view code in blog]  To understand what‚Äôs happening here it helps to walk though the example one statement at a time. Line 30 declares a variable named message with a greeting. Lines 31-33 declare a function named printMessage() that prints the contents of the variable declared on line 30. Line 34 calls the method and produces the expected result. So far it‚Äôs extremely straightforward.  The subtle distinctions start on line 35 which assigns a new value to the variable declared in line 30, and line 36 which prints this new value as expected. On the other hand, line 37 declares a new variable with the same name. This effectively hides the original variable from all subsequent code, but the call on line 38 invokes a function that was compiled before the redefinition. The function retains its original meaning and prints the value of the original variable, not the newly declared variable. Line 39 shows that the newly defined variable can be referenced, as expected, by new code.  All redefinitions work in this manner, whether they‚Äôre redefining a function, a variable, or a type. The REPL grants the freedom to redefine an identifier without restrictions, whereas prior references were compiled with strong semantic checks in place. What would happen if the message identifier in the example above were redefined as a type instead of a variable? The printMessage() function would no longer compile. Rather than ask developers to sort through endless potential edge cases like this, the REPL adheres to a world view that is always self-consistent. </description>
<pubDate>Fri, 23 Jan 2015 14:50:00 PST</pubDate>
<content:encoded><![CDATA[<p>Our <a href="https://developer.apple.com/swift/blog/?id=18">first entry on the REPL</a> covered just the basics, showing how to use the REPL to experiment with Swift as you learn the language. This post explores one way that the REPL bends normal coding rules to give you new powers when developing.</p><h3>Redefining Identifiers</h3><p>The Swift compiler automatically protects against a wide range of programming mistakes, including unintentional ambiguity arising from defining the same identifier twice:</p><a href="http://developer.apple.com/swift/blog/?id=20">[view code in blog]</a><p>This makes sense when coding in a non-interactive editor, but in the REPL interactive environment it‚Äôs useful to be able to easily make changes. The REPL was specifically designed with this kind of convenience in mind:</p><a href="http://developer.apple.com/swift/blog/?id=20">[view code in blog]</a><p>The newer definition replaces the existing definition for all subsequent references. As illustrated above, even the type of the definition can be changed in the process. This allows a wide range of experiments through iterative refinement. For example, you can start out with a recursive implementation of a function:</p><a href="http://developer.apple.com/swift/blog/?id=20">[view code in blog]</a><p>This is just one way to write this function. You can experiment with your code, trying out different algorithms and APIs. The REPL makes it easy to define a new and improved implementation:</p><a href="http://developer.apple.com/swift/blog/?id=20">[view code in blog]</a><p>Typing the same expression in the REPL now executes the new implementation. This is a simple example, but it illustrates the iterative experimentation that the REPL was designed to facilitate.</p><h3>Redefinition or Overload?</h3><p>Redefining constants, variables, and types all work intuitively, and, as we can see above, it is also possible to redefine functions. This raises an obvious question: how does this interact with function overloading? The REPL only replaces an existing definition when it has the same name and signature as shown in the Fibonacci example above. If a function with the same name but a distinct signature already exists, it just defines a new overload. Keep in mind that Swift allows function overloading even when two signatures differ only in their return type. For example:</p><a href="http://developer.apple.com/swift/blog/?id=20">[view code in blog]</a><p>The above declarations define two distinct functions that must be called in a manner where only one of the available overloads can be inferred as returning a compatible type:</p><a href="http://developer.apple.com/swift/blog/?id=20">[view code in blog]</a><h3>Capturing Definitions</h3><p>The ability to redefine an identifier is powerful, but it only applies to subsequent uses of the identifier. Any line of code that has already been compiled by the REPL retains its reference to the previous definition. It‚Äôs as if the new definition obscures the old one but doesn‚Äôt eliminate it entirely. The following illustrates how this works in practice:</p><a href="http://developer.apple.com/swift/blog/?id=20">[view code in blog]</a><p>To understand what‚Äôs happening here it helps to walk though the example one statement at a time. Line 30 declares a variable named message with a greeting. Lines 31-33 declare a function named printMessage() that prints the contents of the variable declared on line 30. Line 34 calls the method and produces the expected result. So far it‚Äôs extremely straightforward.</p><p>The subtle distinctions start on line 35 which assigns a new value to the variable declared in line 30, and line 36 which prints this new value as expected. On the other hand, line 37 declares a new variable with the same name. This effectively hides the original variable from all subsequent code, but the call on line 38 invokes a function that was compiled before the redefinition. The function retains its original meaning and prints the value of the original variable, not the newly declared variable. Line 39 shows that the newly defined variable can be referenced, as expected, by new code.</p><p>All redefinitions work in this manner, whether they‚Äôre redefining a function, a variable, or a type. The REPL grants the freedom to redefine an identifier without restrictions, whereas prior references were compiled with strong semantic checks in place. What would happen if the message identifier in the example above were redefined as a type instead of a variable? The printMessage() function would no longer compile. Rather than ask developers to sort through endless potential edge cases like this, the REPL adheres to a world view that is always self-consistent.</p>]]></content:encoded>
</item>
<item>
<title>What Happened to  NSMethodSignature ?</title>
<link>http://developer.apple.com/swift/blog/?id=19</link>
<guid>http://developer.apple.com/swift/blog/?id=19</guid>
<description> UPDATE: We‚Äôve added the Request.playground file to this post so you can download it and easily experiment with the code yourself.  Bringing the Cocoa frameworks to Swift gave us a unique opportunity to look at our APIs with a fresh perspective. We found classes that we didn't feel fit with the goals of Swift, most often due to the priority we give to safety.  For instance, some classes related to dynamic method invocation are not exposed in Swift, namely  NSInvocation  and  NSMethodSignature .  We recently received a bug report from a developer who noticed this absence. This developer was using  NSMethodSignature  in Objective-C to introspect the types of method arguments, and in the process of migrating this code to Swift, noticed that  NSMethodSignature  is not available. The code being migrated could accept HTTP handlers of varying signatures, such as:  [view code in blog]  In Objective-C,  NSMethodSignature  can be used to determine that the API of the first method would require a  [String: String]  argument, and the second method would require a  JSON  value. However, Swift is a powerful language and can easily handle this scenario without using  NSMethodSignature , and in a way that doesn't undermine the help that the compiler provides for type and memory safety.  Here is an alternative way to solve the same problem in Swift:  [view code in blog]  First, we'll use a protocol to define that whatever is going to handle our  HTTPRequest  does so via this interface. This protocol is very simple, with only a single method.  Why use a protocol here, instead of subclassing an  HTTPHandler  class? Because protocols give the flexibility of leaving the implementation details up to the clients of this code. If we were to make an  HTTPHandler  class, we would require clients to also use classes, forcing upon them the semantics of reference types. However, by using a protocol, clients can decide for themselves the appropriate type to use in their code, whether it be class, struct, or even enum.  [view code in blog]  Next, our  HTTPServer  class has a generic method that accepts an  HTTPHandlerType  as a parameter. By using the handler's associated type, it can perform the conditional downcast of the  args  parameter to determine if this handler should be given an opportunity to handle the request. Here we can see the benefit of defining  HTTPHandlerType  as a protocol. The  HTTPServer  doesn't need to know  how  the handler is reacting to the request, nor does it even need to care about the nature of the handler itself. All it needs to know is that the value can handle requests.  [view code in blog]  When our  HTTPServer  receives a request, it will iterate through its handlers and see if any can deal with the request.  Now we can easily create a custom  HTTPHandlerType  with varying argument types and register it with the  HTTPServer :  [view code in blog]  With a combination of protocols and generics, we have written Swift code to elegantly create and register HTTP handlers of varying types. This approach also lets the compiler guarantee type safety, while ensuring excellent runtime performance. </description>
<pubDate>Fri, 12 Dec 2014 12:00:00 PST</pubDate>
<content:encoded><![CDATA[<p class="update">UPDATE: We‚Äôve added the Request.playground file to this post so you can download it and easily experiment with the code yourself.</p><p>Bringing the Cocoa frameworks to Swift gave us a unique opportunity to look at our APIs with a fresh perspective. We found classes that we didn't feel fit with the goals of Swift, most often due to the priority we give to safety.  For instance, some classes related to dynamic method invocation are not exposed in Swift, namely <span class="keyword">NSInvocation</span> and <span class="keyword">NSMethodSignature</span>.</p><p>We recently received a bug report from a developer who noticed this absence. This developer was using <span class="keyword">NSMethodSignature</span> in Objective-C to introspect the types of method arguments, and in the process of migrating this code to Swift, noticed that <span class="keyword">NSMethodSignature</span> is not available. The code being migrated could accept HTTP handlers of varying signatures, such as:</p><a href="http://developer.apple.com/swift/blog/?id=19">[view code in blog]</a><p>In Objective-C, <span class="keyword">NSMethodSignature</span> can be used to determine that the API of the first method would require a <span class="keyword">[String: String]</span> argument, and the second method would require a <span class="keyword">JSON</span> value. However, Swift is a powerful language and can easily handle this scenario without using <span class="keyword">NSMethodSignature</span>, and in a way that doesn't undermine the help that the compiler provides for type and memory safety.</p><p>Here is an alternative way to solve the same problem in Swift:</p><a href="http://developer.apple.com/swift/blog/?id=19">[view code in blog]</a><p>First, we'll use a protocol to define that whatever is going to handle our <span class="keyword">HTTPRequest</span> does so via this interface. This protocol is very simple, with only a single method.</p><p>Why use a protocol here, instead of subclassing an <span class="keyword">HTTPHandler</span> class? Because protocols give the flexibility of leaving the implementation details up to the clients of this code. If we were to make an <span class="keyword">HTTPHandler</span> class, we would require clients to also use classes, forcing upon them the semantics of reference types. However, by using a protocol, clients can decide for themselves the appropriate type to use in their code, whether it be class, struct, or even enum.</p><a href="http://developer.apple.com/swift/blog/?id=19">[view code in blog]</a><p>Next, our <span class="keyword">HTTPServer</span> class has a generic method that accepts an <span class="keyword">HTTPHandlerType</span> as a parameter. By using the handler's associated type, it can perform the conditional downcast of the <span class="keyword">args</span> parameter to determine if this handler should be given an opportunity to handle the request. Here we can see the benefit of defining <span class="keyword">HTTPHandlerType</span> as a protocol. The <span class="keyword">HTTPServer</span> doesn't need to know <em>how</em> the handler is reacting to the request, nor does it even need to care about the nature of the handler itself. All it needs to know is that the value can handle requests.</p><a href="http://developer.apple.com/swift/blog/?id=19">[view code in blog]</a><p>When our <span class="keyword">HTTPServer</span> receives a request, it will iterate through its handlers and see if any can deal with the request.</p><p>Now we can easily create a custom <span class="keyword">HTTPHandlerType</span> with varying argument types and register it with the <span class="keyword">HTTPServer</span>:</p><a href="http://developer.apple.com/swift/blog/?id=19">[view code in blog]</a><p>With a combination of protocols and generics, we have written Swift code to elegantly create and register HTTP handlers of varying types. This approach also lets the compiler guarantee type safety, while ensuring excellent runtime performance.</p>]]></content:encoded>
</item>
<item>
<title>Introduction to the Swift REPL</title>
<link>http://developer.apple.com/swift/blog/?id=18</link>
<guid>http://developer.apple.com/swift/blog/?id=18</guid>
<description> Xcode 6.1 introduces yet another way to experiment with Swift in the form of an interactive Read Eval Print Loop, or REPL. Developers familiar with interpreted languages will feel comfortable in this command-line environment, and even experienced developers will find a few unique features. To get started, launch Terminal.app (found in /Applications/Utilities) and type ‚Äúswift‚Äù at the prompt in OS X Yosemite, or ‚Äúxcrun swift‚Äù in OS X Mavericks. You‚Äôll then be in the Swift REPL: [view code in blog]   All you need to do is type Swift statements and the REPL will immediately execute your code.  Expression results are automatically formatted and displayed along with their type, as are the results of both variable and constant declarations.  Console output flows naturally within the interactive session:  [view code in blog]  Note that the result from line one has been given a name by the REPL even though the result of the expression wasn‚Äôt explicitly assigned to anything.  You can reference these results to reuse their values in subsequent statements:  [view code in blog]  The Swift compiler recognizes incomplete code, and will prompt for additional input when needed.  Your code will even be indented automatically as it would in Xcode. For instance, starting a function:  [view code in blog]  The prompt for continuation lines is a line number followed by a period instead of the angle bracket that indicates a new statement, so you can tell at a glance when you‚Äôre being asked to complete a code fragment.  At this point you can keep typing remaining lines in the method:  [view code in blog]  There are three noteworthy points to make here:  The first is that line six was originally indented, but the REPL automatically unindented when we typed the closing brace.  The second is that the function references a parameter we forgot to declare and needs a return type, so you‚Äôll need to add both to the declaration.  The last is that even if you did press return after the last line, it‚Äôs not too late to fix it.  Multi-Line History  When code is submitted to the compiler it‚Äôs also recorded in the REPL history, which makes correcting mistakes trivial.  If you pressed return at the end of the incomplete function declaration above, you‚Äôd be presented with the following message:  [view code in blog]  Like most history implementations, you can call up your last entry by pressing up arrow from the prompt.  The REPL brings back all three lines in our example, and places the cursor at the end.  You can now proceed with editing the code to correct your mistake as described in the next section.  Your history is preserved between sessions and will record hundreds of code fragments.  Each time you move up from the top line you‚Äôll move to an earlier history entry.  Each time you move down from an empty line at the bottom of an entry you‚Äôll move to a more recent history entry.  The empty line that opens up before moving to the next entry comes in handy for reasons discussed below.  Multi-Line Editing  Even though the REPL behaves like a traditional line editor, it also provides convenient features for dealing with multi-line input like most class or function declarations.  In the example above, before pressing return on the final line you can press up arrow to move the cursor up to the declaration line, then use the left arrow to move the cursor just after the opening parenthesis for the parameter list:  [view code in blog]  Type the parameter declaration, press the right arrow to move past the closing parenthesis and add the return type as well:  [view code in blog]  You can‚Äôt press return to complete the declaration at this point because you‚Äôre in the middle of a block of text.  Pressing return here would insert a line break, which can be useful if you‚Äôre trying to insert additional lines in a function or method body, but what you want here is to move to the end of the declaration.  You can press down arrow twice to get there, or use the Emacs sequence  ESC >  (the escape key followed by a closing angle bracket).  Pressing return at the end of the last line will compile the newly declared function so it‚Äôs ready for use:  [view code in blog]  Automatic detection of statement completion means that you can just type code and the REPL will do the right thing the vast majority of the time.  There are occasions, however, where it‚Äôs necessary to submit more than one declaration at the same time because they have mutual dependencies. Consider the following code:  [view code in blog]  Typing everything above line by line will result in trying to compile the first function once the third line is complete, and of course this produces an error:  [view code in blog]  You could declare both functions on a single line to get around automatic completion detection that takes place when you press return, but there‚Äôs a better solution.  After typing the third line above you can press the down arrow to move to create a fourth line manually, and type the remainder normally.  The two declarations are compiled together, achieving the desired goal of mutual recursion.  Quick Reference  To help you get started, here‚Äôs a handy chart with some of the most commonly used editing and navigation keys:  [view code in blog] </description>
<pubDate>Tue, 11 Nov 2014 11:00:00 PST</pubDate>
<content:encoded><![CDATA[<p>Xcode 6.1 introduces yet another way to experiment with Swift in the form of an interactive Read Eval Print Loop, or REPL. Developers familiar with interpreted languages will feel comfortable in this command-line environment, and even experienced developers will find a few unique features. To get started, launch Terminal.app (found in /Applications/Utilities) and type ‚Äúswift‚Äù at the prompt in OS X Yosemite, or ‚Äúxcrun swift‚Äù in OS X Mavericks. You‚Äôll then be in the Swift REPL:<a href="http://developer.apple.com/swift/blog/?id=18">[view code in blog]</a></p><p>All you need to do is type Swift statements and the REPL will immediately execute your code.  Expression results are automatically formatted and displayed along with their type, as are the results of both variable and constant declarations.  Console output flows naturally within the interactive session:</p><a href="http://developer.apple.com/swift/blog/?id=18">[view code in blog]</a><p>Note that the result from line one has been given a name by the REPL even though the result of the expression wasn‚Äôt explicitly assigned to anything.  You can reference these results to reuse their values in subsequent statements:</p><a href="http://developer.apple.com/swift/blog/?id=18">[view code in blog]</a><p>The Swift compiler recognizes incomplete code, and will prompt for additional input when needed.  Your code will even be indented automatically as it would in Xcode. For instance, starting a function:</p><a href="http://developer.apple.com/swift/blog/?id=18">[view code in blog]</a><p>The prompt for continuation lines is a line number followed by a period instead of the angle bracket that indicates a new statement, so you can tell at a glance when you‚Äôre being asked to complete a code fragment.  At this point you can keep typing remaining lines in the method:</p><a href="http://developer.apple.com/swift/blog/?id=18">[view code in blog]</a><p>There are three noteworthy points to make here:  The first is that line six was originally indented, but the REPL automatically unindented when we typed the closing brace.  The second is that the function references a parameter we forgot to declare and needs a return type, so you‚Äôll need to add both to the declaration.  The last is that even if you did press return after the last line, it‚Äôs not too late to fix it.</p><h3>Multi-Line History</h3><p>When code is submitted to the compiler it‚Äôs also recorded in the REPL history, which makes correcting mistakes trivial.  If you pressed return at the end of the incomplete function declaration above, you‚Äôd be presented with the following message:</p><a href="http://developer.apple.com/swift/blog/?id=18">[view code in blog]</a><p>Like most history implementations, you can call up your last entry by pressing up arrow from the prompt.  The REPL brings back all three lines in our example, and places the cursor at the end.  You can now proceed with editing the code to correct your mistake as described in the next section.</p><p>Your history is preserved between sessions and will record hundreds of code fragments.  Each time you move up from the top line you‚Äôll move to an earlier history entry.  Each time you move down from an empty line at the bottom of an entry you‚Äôll move to a more recent history entry.  The empty line that opens up before moving to the next entry comes in handy for reasons discussed below.</p><h3>Multi-Line Editing</h3><p>Even though the REPL behaves like a traditional line editor, it also provides convenient features for dealing with multi-line input like most class or function declarations.  In the example above, before pressing return on the final line you can press up arrow to move the cursor up to the declaration line, then use the left arrow to move the cursor just after the opening parenthesis for the parameter list:</p><a href="http://developer.apple.com/swift/blog/?id=18">[view code in blog]</a><p>Type the parameter declaration, press the right arrow to move past the closing parenthesis and add the return type as well:</p><a href="http://developer.apple.com/swift/blog/?id=18">[view code in blog]</a><p>You can‚Äôt press return to complete the declaration at this point because you‚Äôre in the middle of a block of text.  Pressing return here would insert a line break, which can be useful if you‚Äôre trying to insert additional lines in a function or method body, but what you want here is to move to the end of the declaration.  You can press down arrow twice to get there, or use the Emacs sequence <span class="keyword">ESC ></span> (the escape key followed by a closing angle bracket).  Pressing return at the end of the last line will compile the newly declared function so it‚Äôs ready for use:</p><a href="http://developer.apple.com/swift/blog/?id=18">[view code in blog]</a><p>Automatic detection of statement completion means that you can just type code and the REPL will do the right thing the vast majority of the time.  There are occasions, however, where it‚Äôs necessary to submit more than one declaration at the same time because they have mutual dependencies. Consider the following code:</p><a href="http://developer.apple.com/swift/blog/?id=18">[view code in blog]</a><p>Typing everything above line by line will result in trying to compile the first function once the third line is complete, and of course this produces an error:</p><a href="http://developer.apple.com/swift/blog/?id=18">[view code in blog]</a><p>You could declare both functions on a single line to get around automatic completion detection that takes place when you press return, but there‚Äôs a better solution.  After typing the third line above you can press the down arrow to move to create a fourth line manually, and type the remainder normally.  The two declarations are compiled together, achieving the desired goal of mutual recursion.</p><h3>Quick Reference</h3><p>To help you get started, here‚Äôs a handy chart with some of the most commonly used editing and navigation keys:</p><a href="http://developer.apple.com/swift/blog/?id=18">[view code in blog]</a>]]></content:encoded>
</item>
<item>
<title>Failable Initializers</title>
<link>http://developer.apple.com/swift/blog/?id=17</link>
<guid>http://developer.apple.com/swift/blog/?id=17</guid>
<description> Swift version 1.1 is new in  Xcode 6.1 , and it introduces a new feature: failable initializers. Initialization is the process of providing initial values to each of the stored properties of a  class  or  struct , establishing the invariants of the object. In some cases initialization can fail. For example, initializing the object requires access to a resource, such as loading an image from a file:  [view code in blog]  If the file does not exist or is unreadable for any reason, the initialization of the  NSImage  will fail. With Swift version 1.1, such failures can be reported using a failable initializer. When constructing an object using a failable initializer, the result is an optional that either contains the object (when the initialization succeeded) or contains  nil  (when the initialization failed). Therefore, the initialization above should handle the optional result directly:  [view code in blog]  An initializer defined with  init  can be made failable by adding a  ?  or a  !  after the  init , which indicates the form of optional that will be produced by constructing an object with that initializer. For example, one could add a failable initializer to  Int  that attempts to perform a conversion from a  String :  [view code in blog]  In a failable initializer,  return nil  indicates that initialization has failed; no other value can be returned. In the example, failure occurs when the string could not be parsed as an integer. Otherwise,  self  is initialized to the parsed value.  Failable initializers eliminate the most common reason for factory methods in Swift, which were previously the only way to report failure when constructing this object. For example, enums that have a raw type provided a factory method  fromRaw  that returned an optional enum. Now, the Swift compiler synthesizes a failable initializer that takes a raw value and attempts to map it to one of the enum cases. For example:  [view code in blog]  Using the failable initializer allows greater use of Swift‚Äôs uniform construction syntax, which simplifies the language by eliminating the confusion and duplication between initializers and factory methods. Along with the introduction of failable initializers, Swift now treats more Cocoa factory methods ‚Äî those with  NSError  arguments ‚Äî as initializers, providing a more uniform experience for object construction.   You can read more about failable initializers in   The Swift Programming Language  . </description>
<pubDate>Mon, 20 Oct 2014 12:00:00 PDT</pubDate>
<content:encoded><![CDATA[<p>Swift version 1.1 is new in <a href="http://developer.apple.com/xcode/downloads/">Xcode 6.1</a>, and it introduces a new feature: failable initializers. Initialization is the process of providing initial values to each of the stored properties of a <span class="keyword">class</span> or <span class="keyword">struct</span>, establishing the invariants of the object. In some cases initialization can fail. For example, initializing the object requires access to a resource, such as loading an image from a file:</p><a href="http://developer.apple.com/swift/blog/?id=17">[view code in blog]</a><p>If the file does not exist or is unreadable for any reason, the initialization of the <span class="keyword">NSImage</span> will fail. With Swift version 1.1, such failures can be reported using a failable initializer. When constructing an object using a failable initializer, the result is an optional that either contains the object (when the initialization succeeded) or contains <span class="keyword">nil</span> (when the initialization failed). Therefore, the initialization above should handle the optional result directly:</p><a href="http://developer.apple.com/swift/blog/?id=17">[view code in blog]</a><p>An initializer defined with <span class="keyword">init</span> can be made failable by adding a <span class="keyword">?</span> or a <span class="keyword">!</span> after the <span class="keyword">init</span>, which indicates the form of optional that will be produced by constructing an object with that initializer. For example, one could add a failable initializer to <span class="keyword">Int</span> that attempts to perform a conversion from a <span class="keyword">String</span>:</p><a href="http://developer.apple.com/swift/blog/?id=17">[view code in blog]</a><p>In a failable initializer, <span class="keyword">return nil</span> indicates that initialization has failed; no other value can be returned. In the example, failure occurs when the string could not be parsed as an integer. Otherwise, <span class="keyword">self</span> is initialized to the parsed value.</p><p>Failable initializers eliminate the most common reason for factory methods in Swift, which were previously the only way to report failure when constructing this object. For example, enums that have a raw type provided a factory method <span class="keyword">fromRaw</span> that returned an optional enum. Now, the Swift compiler synthesizes a failable initializer that takes a raw value and attempts to map it to one of the enum cases. For example:</p><a href="http://developer.apple.com/swift/blog/?id=17">[view code in blog]</a><p>Using the failable initializer allows greater use of Swift‚Äôs uniform construction syntax, which simplifies the language by eliminating the confusion and duplication between initializers and factory methods. Along with the introduction of failable initializers, Swift now treats more Cocoa factory methods ‚Äî those with <span class="keyword">NSError</span> arguments ‚Äî as initializers, providing a more uniform experience for object construction.</p> <p>You can read more about failable initializers in <a href="http://developer.apple.com/library/mac/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html#//apple_ref/doc/uid/TP40014097-CH18-XID_339"><span class="nowrap">The Swift Programming Language</span></a>.</p>]]></content:encoded>
</item>
<item>
<title>Building Your First Swift App Video</title>
<link>http://developer.apple.com/swift/blog/?id=16</link>
<guid>http://developer.apple.com/swift/blog/?id=16</guid>
<description> UPDATE: To make it easier to follow along, we‚Äôve included the  code  you see pasted in the video.  So far the Swift blog has focused on advanced programming topics, including the design principles of the Swift language. We thought it would be helpful to provide content for programmers who are new to Swift and just trying Xcode for the first time. To make it more approachable for everyone, we put together a very short video that demonstrates how to build an iOS app in Swift from scratch, in less than ten minutes.   Watch the video  </description>
<pubDate>Tue, 07 Oct 2014 11:00:00 PDT</pubDate>
<content:encoded><![CDATA[<p class="update">UPDATE: To make it easier to follow along, we‚Äôve included the <a href="http://developer.apple.com/swift/blog/downloads/ViewController.txt">code</a> you see pasted in the video.</p><p>So far the Swift blog has focused on advanced programming topics, including the design principles of the Swift language. We thought it would be helpful to provide content for programmers who are new to Swift and just trying Xcode for the first time. To make it more approachable for everyone, we put together a very short video that demonstrates how to build an iOS app in Swift from scratch, in less than ten minutes.</p><p><a href="http://developer.apple.com/swift/blog/?id=16">Watch the video</a></p>]]></content:encoded>
</item>
<item>
<title>Building  assert()  in Swift, Part 2:  __FILE__  and  __LINE__ </title>
<link>http://developer.apple.com/swift/blog/?id=15</link>
<guid>http://developer.apple.com/swift/blog/?id=15</guid>
<description> Two occasionally useful features of C are the  __FILE__  and  __LINE__  magic macros. These are built into the preprocessor, and expanded out before the C parser is run. Despite not having a preprocessor, Swift provides very similar functionality with similar names, but Swift works quite differently under the covers.  Built-In Identifiers  As described in  the Swift programming guide , Swift has a number of built-in identifiers, including   __FILE__ ,  __LINE__ ,  __COLUMN__ , and  __FUNCTION__ . These expressions can be used anywhere and are expanded by the parser to string or integer literals that correspond to the current location in the source code. This is incredibly useful for manual logging, e.g. to print out the current position before quitting.  However, this doesn‚Äôt help us in our quest to implement  assert() .  If we defined assert like this:  [view code in blog]  The above code would print out of the file/line location that implements  assert()  itself, not the location from the caller. That isn‚Äôt helpful.  Getting the location of a caller  Swift borrows a clever feature from the D language: these identifiers expand to the location of the caller  when evaluated in a default argument list .  To enable this behavior, the  assert()  function is defined something like this:  [view code in blog]  The second parameter to the Swift  assert()  function is an optional string that you can specify, and the third and forth arguments are defaulted to be the position in the caller‚Äôs context.  This allows  assert()  to pick up the source location of the caller by default, and if you want to define your own abstractions on top of assert, you can pass down locations from its caller.  As a trivial example, you could define a function that logs and asserts like this:  [view code in blog]  This properly propagates the file/line location of the  logAndAssert()  caller down to the implementation of  assert() . Note that  StaticString , as shown in the code above, is a simple  String-like  type used to store a string literal, such as one produced by  __FILE__ , with no  memory-management  overhead.  In addition to being useful for  assert() , this functionality is used in the Swift implementation of the higher-level XCTest framework, and may be useful for your own libraries as well. </description>
<pubDate>Thu, 25 Sep 2014 10:00:00 PDT</pubDate>
<content:encoded><![CDATA[<p>Two occasionally useful features of C are the <span class="keyword">__FILE__</span> and <span class="keyword">__LINE__</span> magic macros. These are built into the preprocessor, and expanded out before the C parser is run. Despite not having a preprocessor, Swift provides very similar functionality with similar names, but Swift works quite differently under the covers.</p><h3>Built-In Identifiers</h3><p>As described in <a href="http://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/LexicalStructure.html">the Swift programming guide</a>, Swift has a number of built-in identifiers, including  <span class="keyword">__FILE__</span>, <span class="keyword">__LINE__</span>, <span class="keyword">__COLUMN__</span>, and <span class="keyword">__FUNCTION__</span>. These expressions can be used anywhere and are expanded by the parser to string or integer literals that correspond to the current location in the source code. This is incredibly useful for manual logging, e.g. to print out the current position before quitting.</p><p>However, this doesn‚Äôt help us in our quest to implement <span class="keyword">assert()</span>.  If we defined assert like this:</p><a href="http://developer.apple.com/swift/blog/?id=15">[view code in blog]</a><p>The above code would print out of the file/line location that implements <span class="keyword">assert()</span> itself, not the location from the caller. That isn‚Äôt helpful.</p><h3>Getting the location of a caller</h3><p>Swift borrows a clever feature from the D language: these identifiers expand to the location of the caller <em>when evaluated in a default argument list</em>.  To enable this behavior, the <span class="keyword">assert()</span> function is defined something like this:</p><a href="http://developer.apple.com/swift/blog/?id=15">[view code in blog]</a><p>The second parameter to the Swift <span class="keyword">assert()</span> function is an optional string that you can specify, and the third and forth arguments are defaulted to be the position in the caller‚Äôs context.  This allows <span class="keyword">assert()</span> to pick up the source location of the caller by default, and if you want to define your own abstractions on top of assert, you can pass down locations from its caller.  As a trivial example, you could define a function that logs and asserts like this:</p><a href="http://developer.apple.com/swift/blog/?id=15">[view code in blog]</a><p>This properly propagates the file/line location of the <span class="keyword">logAndAssert()</span> caller down to the implementation of <span class="keyword">assert()</span>. Note that <span class="keyword">StaticString</span>, as shown in the code above, is a simple <span class="nowrap">String-like</span> type used to store a string literal, such as one produced by <span class="keyword">__FILE__</span>, with no <span class="nowrap">memory-management</span> overhead.</p><p>In addition to being useful for <span class="keyword">assert()</span>, this functionality is used in the Swift implementation of the higher-level XCTest framework, and may be useful for your own libraries as well.</p>]]></content:encoded>
</item>
<item>
<title>Swift Has Reached 1.0</title>
<link>http://developer.apple.com/swift/blog/?id=14</link>
<guid>http://developer.apple.com/swift/blog/?id=14</guid>
<description> On June 2, 2014 at WWDC, the Swift team finally showed you what we had been working on for years. That was a  big day with lots of excitement, for us and for developers around the world. Today, we‚Äôve reached the second giant milestone:  Swift version 1.0 is now GM.  You can now submit your apps that use Swift to the App Store. Whether your app uses Swift for a small feature or a complete application, now is the time to share your app with the world. It‚Äôs your turn to excite everyone with your new creations.  Swift for OS X  Today is the GM date for Swift on iOS. We have one more GM date to go for Mac. Swift for OS X currently requires the SDK for OS X Yosemite, and when Yosemite ships later this fall, Swift will also be GM on the Mac. In the meantime, you can keep developing your Mac apps with Swift by downloading the beta of  Xcode 6.1 .  The Road Ahead  You‚Äôll notice we‚Äôre using the word ‚ÄúGM‚Äù, not ‚Äúfinal‚Äù. That‚Äôs because Swift will continue to advance with new features, improved performance, and refined syntax. In fact, you can expect a few improvements to come in Xcode 6.1 in time for the Yosemite launch. Because your apps today embed a version of the Swift GM runtime, they will continue to run well into the future. </description>
<pubDate>Tue, 09 Sep 2014 11:00:00 PDT</pubDate>
<content:encoded><![CDATA[<p>On June 2, 2014 at WWDC, the Swift team finally showed you what we had been working on for years. That was a  big day with lots of excitement, for us and for developers around the world. Today, we‚Äôve reached the second giant milestone:</p><p>Swift version 1.0 is now GM.</p><p>You can now submit your apps that use Swift to the App Store. Whether your app uses Swift for a small feature or a complete application, now is the time to share your app with the world. It‚Äôs your turn to excite everyone with your new creations.</p><h3>Swift for OS X</h3><p>Today is the GM date for Swift on iOS. We have one more GM date to go for Mac. Swift for OS X currently requires the SDK for OS X Yosemite, and when Yosemite ships later this fall, Swift will also be GM on the Mac. In the meantime, you can keep developing your Mac apps with Swift by downloading the beta of <a href="http://developer.apple.com/xcode/downloads/">Xcode 6.1</a>.</p><h3>The Road Ahead</h3><p>You‚Äôll notice we‚Äôre using the word ‚ÄúGM‚Äù, not ‚Äúfinal‚Äù. That‚Äôs because Swift will continue to advance with new features, improved performance, and refined syntax. In fact, you can expect a few improvements to come in Xcode 6.1 in time for the Yosemite launch. Because your apps today embed a version of the Swift GM runtime, they will continue to run well into the future.</p>]]></content:encoded>
</item>
<item>
<title>Patterns Playground</title>
<link>http://developer.apple.com/swift/blog/?id=13</link>
<guid>http://developer.apple.com/swift/blog/?id=13</guid>
<description> In Swift, a pattern is a way to describe and match a set of values based on certain rules, such as:    All tuples whose first value is 0  All numbers in the range 1...5  All class instances of a certain type   The learning playground linked below includes embedded documentation and experiments for you to perform. Download it for an interactive experience that will give you a jump start into using patterns in your own apps.  This playground requires the latest beta version of Xcode 6 on OS X Mavericks or OS X Yosemite beta. </description>
<pubDate>Wed, 03 Sep 2014 09:00:00 PDT</pubDate>
<content:encoded><![CDATA[<p>In Swift, a pattern is a way to describe and match a set of values based on certain rules, such as: </p><ul><li>All tuples whose first value is 0</li><li>All numbers in the range 1...5</li><li>All class instances of a certain type</li></ul><p>The learning playground linked below includes embedded documentation and experiments for you to perform. Download it for an interactive experience that will give you a jump start into using patterns in your own apps.</p><p>This playground requires the latest beta version of Xcode 6 on OS X Mavericks or OS X Yosemite beta.</p>]]></content:encoded>
</item>
<item>
<title>Optionals Case Study:  valuesForKeys </title>
<link>http://developer.apple.com/swift/blog/?id=12</link>
<guid>http://developer.apple.com/swift/blog/?id=12</guid>
<description> This post explores how optionals help preserve strong type safety within Swift. We‚Äôre going to create a Swift version of an Objective-C API. Swift doesn‚Äôt really need this API, but it makes for a fun example.  In Objective-C,  NSDictionary  has a method  -objectsForKeys:notFoundMarker:  that takes an  NSArray  of keys, and returns an  NSArray  of corresponding values. From the documentation: ‚Äúthe  N -th object in the returned array corresponds to the  N -th key in [the input parameter] keys.‚Äù What if the third key isn‚Äôt actually in the dictionary? That‚Äôs where the  notFoundMarker  parameter comes in. The third element in the array will be this marker object rather than a value from the dictionary. The Foundation framework even provides a class for this case if you don‚Äôt have another to use:  NSNull .  In Swift, the  Dictionary  type doesn‚Äôt have an  objectsForKeys  equivalent. For this exercise, we‚Äôre going to add one ‚Äî as  valuesForKeys  in keeping with the common use of ‚Äòvalue‚Äô in Swift ‚Äî using an extension:  [view code in blog]  This is where our new implementation in Swift will differ from Objective-C. In Swift, the stronger typing restricts the resulting array to contain only a single type of element ‚Äî we can‚Äôt put  NSNull  in an array of strings. However, Swift gives an even better option: we can return an  array of optionals . All our values get wrapped in optionals, and instead of  NSNull , we just use  nil .  [view code in blog]  NOTE: Some of you may have guessed why a Swift  Dictionary  doesn‚Äôt need this API, and already imagined something like this:  [view code in blog]  This has the exact same effect as the imperative version above, but all of the boilerplate has been wrapped up in the call to  map . This is great example why Swift types often have a small API surface area, because it‚Äôs so easy to just call  map  directly.  Now we can try out some examples:  [view code in blog]  Nested Optionals  Now, what if we asked for the  last  element of each result?  [view code in blog]  That‚Äôs strange ‚Äî we have two levels of  Optional  in the first case, and  Optional(nil)  in the second case. What‚Äôs going on?  Remember the declaration of the  last  property:  [view code in blog]  This says that the  last  property‚Äôs type is an  Optional  version of the array‚Äôs element type. In  this  case, the element type is also optional ( String? ). So we end up with  String?? , a doubly-nested optional type.  So what does  Optional(nil)  mean?  Recall that in Objective-C we were going to use  NSNull  as a placeholder. The Objective-C version of these three calls looks like this:  [view code in blog]  In both the Swift and Objective-C cases, a return value of  nil  means ‚Äúthe array is empty, therefore there‚Äôs no last element.‚Äù The return value of  Optional(nil)  (or in Objective-C  NSNull ) means ‚Äúthe last element of this array exists, but it represents an absence.‚Äù Objective-C has to rely on a placeholder object to do this, but Swift can represent it in the type system.  Providing a Default  To wrap up, what if you  did  want to provide a default value for anything that wasn‚Äôt in the dictionary? Well, that‚Äôs easy enough.  [view code in blog]  While Objective-C has to rely on a placeholder object to do this, Swift can represent it in the type system, and provides rich syntactic support for handling optional results. </description>
<pubDate>Tue, 26 Aug 2014 14:00:00 PDT</pubDate>
<content:encoded><![CDATA[<p>This post explores how optionals help preserve strong type safety within Swift. We‚Äôre going to create a Swift version of an Objective-C API. Swift doesn‚Äôt really need this API, but it makes for a fun example.</p><p>In Objective-C, <span class="keyword">NSDictionary</span> has a method <span class="keyword">-objectsForKeys:notFoundMarker:</span> that takes an <span class="keyword">NSArray</span> of keys, and returns an <span class="keyword">NSArray</span> of corresponding values. From the documentation: ‚Äúthe <em>N</em>-th object in the returned array corresponds to the <em>N</em>-th key in [the input parameter] keys.‚Äù What if the third key isn‚Äôt actually in the dictionary? That‚Äôs where the <span class="keyword">notFoundMarker</span> parameter comes in. The third element in the array will be this marker object rather than a value from the dictionary. The Foundation framework even provides a class for this case if you don‚Äôt have another to use: <span class="keyword">NSNull</span>.</p><p>In Swift, the <span class="keyword">Dictionary</span> type doesn‚Äôt have an <span class="keyword">objectsForKeys</span> equivalent. For this exercise, we‚Äôre going to add one ‚Äî as <span class="keyword">valuesForKeys</span> in keeping with the common use of ‚Äòvalue‚Äô in Swift ‚Äî using an extension:</p><a href="http://developer.apple.com/swift/blog/?id=12">[view code in blog]</a><p>This is where our new implementation in Swift will differ from Objective-C. In Swift, the stronger typing restricts the resulting array to contain only a single type of element ‚Äî we can‚Äôt put <span class="keyword">NSNull</span> in an array of strings. However, Swift gives an even better option: we can return an <emn>array of optionals</em>. All our values get wrapped in optionals, and instead of <span class="keyword">NSNull</span>, we just use <span class="keyword">nil</span>.</p><a href="http://developer.apple.com/swift/blog/?id=12">[view code in blog]</a><p>NOTE: Some of you may have guessed why a Swift <span class="keyword">Dictionary</span> doesn‚Äôt need this API, and already imagined something like this:</p><a href="http://developer.apple.com/swift/blog/?id=12">[view code in blog]</a><p>This has the exact same effect as the imperative version above, but all of the boilerplate has been wrapped up in the call to <span class="keyword">map</span>. This is great example why Swift types often have a small API surface area, because it‚Äôs so easy to just call <span class="keyword">map</span> directly.</p><p>Now we can try out some examples:</p><a href="http://developer.apple.com/swift/blog/?id=12">[view code in blog]</a><h3>Nested Optionals</h3><p>Now, what if we asked for the <span class="keyword">last</span> element of each result?</p><a href="http://developer.apple.com/swift/blog/?id=12">[view code in blog]</a><p>That‚Äôs strange ‚Äî we have two levels of <span class="keyword">Optional</span> in the first case, and <span class="keyword">Optional(nil)</span> in the second case. What‚Äôs going on?</p><p>Remember the declaration of the <span class="keyword">last</span> property:</p><a href="http://developer.apple.com/swift/blog/?id=12">[view code in blog]</a><p>This says that the <span class="keyword">last</span> property‚Äôs type is an <span class="keyword">Optional</span> version of the array‚Äôs element type. In <em>this</em> case, the element type is also optional (<span class="keyword">String?</span>). So we end up with <span class="keyword">String??</span>, a doubly-nested optional type.</p><p>So what does <span class="keyword">Optional(nil)</span> mean?</p><p>Recall that in Objective-C we were going to use <span class="keyword">NSNull</span> as a placeholder. The Objective-C version of these three calls looks like this:</p><a href="http://developer.apple.com/swift/blog/?id=12">[view code in blog]</a><p>In both the Swift and Objective-C cases, a return value of <span class="keyword">nil</span> means ‚Äúthe array is empty, therefore there‚Äôs no last element.‚Äù The return value of <span class="keyword">Optional(nil)</span> (or in Objective-C <span class="keyword">NSNull</span>) means ‚Äúthe last element of this array exists, but it represents an absence.‚Äù Objective-C has to rely on a placeholder object to do this, but Swift can represent it in the type system.</p><h3>Providing a Default</h3><p>To wrap up, what if you <em>did</em> want to provide a default value for anything that wasn‚Äôt in the dictionary? Well, that‚Äôs easy enough.</p><a href="http://developer.apple.com/swift/blog/?id=12">[view code in blog]</a><p>While Objective-C has to rely on a placeholder object to do this, Swift can represent it in the type system, and provides rich syntactic support for handling optional results.</p>]]></content:encoded>
</item>

</channel>
</rss>