<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom">
<channel>
<atom:link href="http://developer.apple.com/swift/blog/news.rss" rel="self" type="application/rss+xml" />
<title>Swift Blog - Apple Developer</title>
<link>http://developer.apple.com/swift/blog/</link>
<description>Get the latest news and helpful tips on the Swift programming language from the engineers who created it.</description>
<language>en-US</language>
<lastBuildDate>Wed, 12 Aug 2015 13:25:00 PDT</lastBuildDate>
<generator>Custom</generator>
<copyright>Copyright 2015, Apple Inc.</copyright>

<item>
<title>Swift-er SDK</title>
<link>http://developer.apple.com/swift/blog/?id=31</link>
<guid>http://developer.apple.com/swift/blog/?id=31</guid>
<description> In Xcode 6.3 we added the new  nullability annotations  language feature for Objective-C. This feature gave Objective-C a way to express the same sorts of null and non-null API contracts that Optionals provide in Swift. Xcode 7 continues to make communication between Objective-C and Swift more natural by introducing a lightweight generics model for Objective-C. Generics enable the two languages to safely understand and share collections containing specific kinds of elements.  These features are useful for anyone writing apps that contain both Swift and Objective-C code. But there‚Äôs a much larger collection of Objective-C code that app developers use every day: the frameworks that make up the Apple SDKs. To improve the experience of working with Swift  and  with Objective-C, we made a company-wide effort to provide this information in our SDK headers. In Xcode 7 you‚Äôll find that nearly all of the common frameworks now specify the nullability of their APIs and the elements of their collection types. This takes our Swift interface from this:  [view code in blog]  To this:  [view code in blog]  The last piece of the puzzle is the Xcode 7 tool to convert your code to Swift 2. This tool lives in Xcode under the Edit menu as Convert &#x0200B;&gt; To Latest Swift Syntax. The tool takes a project that uses Swift 1.2 and applies the necessary edits to turn your code into valid Swift 2 code. These changes account for the improved header information. For instance, if you are overriding a method whose parameter and result types are now more precise, the migrator will update your method to match.  The improvements to Objective-C were detailed at WWDC in  Swift and Objective-C Interoperability  starting at the 14:30 mark. Note that this video uses the Xcode 6.3  __nullable  syntax as opposed to the updated syntax in Xcode 7 that uses  _Nullable . For more information on nullability annotations, see the blog post  Nullability and Objective-C . For more information on Swift 2 and Objective-C lightweight generics, see the  Xcode 7 Release Notes . </description>
<pubDate>Wed, 12 Aug 2015 13:25:00 PDT</pubDate>
<content:encoded><![CDATA[<p>In Xcode 6.3 we added the new <a href="https://developer.apple.com/swift/blog/?id=25">nullability annotations</a> language feature for Objective-C. This feature gave Objective-C a way to express the same sorts of null and non-null API contracts that Optionals provide in Swift. Xcode 7 continues to make communication between Objective-C and Swift more natural by introducing a lightweight generics model for Objective-C. Generics enable the two languages to safely understand and share collections containing specific kinds of elements.</p><p>These features are useful for anyone writing apps that contain both Swift and Objective-C code. But there‚Äôs a much larger collection of Objective-C code that app developers use every day: the frameworks that make up the Apple SDKs. To improve the experience of working with Swift <em>and</em> with Objective-C, we made a company-wide effort to provide this information in our SDK headers. In Xcode 7 you‚Äôll find that nearly all of the common frameworks now specify the nullability of their APIs and the elements of their collection types. This takes our Swift interface from this:</p><a href="http://developer.apple.com/swift/blog/?id=31">[view code in blog]</a><p>To this:</p><a href="http://developer.apple.com/swift/blog/?id=31">[view code in blog]</a><p>The last piece of the puzzle is the Xcode 7 tool to convert your code to Swift 2. This tool lives in Xcode under the Edit menu as Convert &#x0200B;&gt; To Latest Swift Syntax. The tool takes a project that uses Swift 1.2 and applies the necessary edits to turn your code into valid Swift 2 code. These changes account for the improved header information. For instance, if you are overriding a method whose parameter and result types are now more precise, the migrator will update your method to match.</p><p>The improvements to Objective-C were detailed at WWDC in <a href="https://developer.apple.com/videos/wwdc/2015/?id=401">Swift and Objective-C Interoperability</a> starting at the 14:30 mark. Note that this video uses the Xcode 6.3 <span class="keyword">__nullable</span> syntax as opposed to the updated syntax in Xcode 7 that uses <span class="keyword">_Nullable</span>. For more information on nullability annotations, see the blog post <a href="https://developer.apple.com/swift/blog/?id=25">Nullability and Objective-C</a>. For more information on Swift 2 and Objective-C lightweight generics, see the <a href="https://developer.apple.com/go/?id=xcode7-beta-release-notes">Xcode 7 Release Notes</a>.</p>]]></content:encoded>
</item>
<item>
<title>Strings in Swift 2</title>
<link>http://developer.apple.com/swift/blog/?id=30</link>
<guid>http://developer.apple.com/swift/blog/?id=30</guid>
<description> Swift provides a performant, Unicode-compliant string implementation as part of its Standard Library. In Swift 2, the  String  type no longer conforms to the  CollectionType  protocol, where  String  was previously a collection of  Character  values, similar to an array. Now,  String  provides a  characters  property that exposes a character collection view.  Why the change? Although it may seem natural to model a string as a collection of characters, the  String  type behaves quite differently from collection types like  Array ,  Set , or  Dictionary . This has always been true, but with the addition of protocol extensions to Swift 2 these differences made it necessary to make several fundamental changes.  Different Than the Sum of Its Parts  When you add an element to a collection, you expect that the collection will contain that element. That is, when you append a value to an array, the array then contains that value. The same applies to a dictionary or a set. However, when you append a combining mark character to a string, the contents of the string itself change.  Consider the string  cafe , which has four characters:  c ,  a ,  f , and  e :  [view code in blog]  If you append the combining acute accent character  U+0301   ¬¥  the string still has four characters, but the last character is now  √© :  [view code in blog]  The string‚Äôs  characters  property does not contain the original lowercase  e , nor does it contain the combining acute accent  ¬¥  that was just appended. Instead, the string now contains a lowercase ‚Äúe‚Äù with acute accent  √© :  [view code in blog]  If we were to treat strings like any other collection, this result would be as surprising as adding  UIColor.redColor()  and  UIColor.greenColor()  to a set and the set then reporting that it contains  UIColor.yellowColor() .  Judged by the Contents of Its Characters  Another difference between strings and collections is the way they determine equality.   Two arrays are equal only if both have the same count, and each pair of elements at corresponding indices are equal.  Two sets are equal only if both have the same count, and each element contained in the first set is also contained in the second.  Two dictionaries are equal only if they have the same set of key, value pairs.   However,  String  determines equality based on being  canonically equivalent . Characters are canonically equivalent if they have the same linguistic meaning and appearance, even if they are composed from different Unicode scalars behind the scenes.  Consider the Korean writing system, which consists of 24 letters, or  Jamo , representing individual consonants and vowels. When written out these letters are combined into characters for each syllable. For example, the character ‚ÄúÍ∞Ä‚Äù ([ga]) is composed of the letters ‚Äú·ÑÄ‚Äù ([g]) and ‚Äú·Ö°‚Äù [a]. In Swift, strings are considered equal regardless of whether they are constructed from decomposed or precomposed character sequences:  [view code in blog]  Again, this behavior differs greatly from any of Swift‚Äôs collection types. It would be as surprising as an array with values  üêü  and  üçö  being considered equal to  üç£ .  Depends on Your Point of View  Strings are not collections. But they do provide  views  that conform to  CollectionType :    characters  is a collection of  Character  values, or  extended grapheme clusters .   unicodeScalars  is a collection of  Unicode scalar values .   utf8  is a collection of  UTF&amp;#8211;8  code units.   utf16  is a collection of  UTF&amp;#8211;16  code units.   If we take the previous example of the word ‚Äúcaf√©‚Äù, comprised of the decomposed characters [ c, a, f, e ] and [ ¬¥ ], here's what the various string views would consist of:    The  characters  property segments the text into  extended grapheme clusters , which are an approximation of user-perceived characters (in this case: c, a, f, and √©). Because a string must iterate through each of its positions within the overall string (each position is called a code point) in order to determine character boundaries, accessing this property is executed in linear  O(n)  time. When processing strings that contain human-readable text, high-level locale-sensitive Unicode algorithms, such as those used by the  localizedStandardCompare(_:)  method and the  localizedLowercaseString  property, should be preferred to character-by-character processing.  The  unicodeScalars  property exposes the underlying scalar values stored in the string. If the original string were created with the precomposed character  √©  instead of the decomposed  e  +  ¬¥ , this would be reflected by the Unicode scalars view. Use this API when you are performing low-level manipulation of character data.  The  utf8  and  utf16  properties provide code points for the UTF‚Äì8 and UTF‚Äì16 representations, respectively. These values correspond to the actual bytes written to a file when translated to and from a particular encoding. UTF-8 code units are used by many POSIX string processing APIs, whereas UTF-16 code units are used throughout Cocoa &amp; Cocoa Touch to represent string lengths and offsets.   For more information about working with Strings and Characters in Swift, read  The Swift Programming Language  and the  Swift Standard Library Reference . </description>
<pubDate>Thu, 23 Jul 2015 14:30:00 PDT</pubDate>
<content:encoded><![CDATA[<p>Swift provides a performant, Unicode-compliant string implementation as part of its Standard Library. In Swift 2, the <span class="keyword">String</span> type no longer conforms to the <span class="keyword">CollectionType</span> protocol, where <span class="keyword">String</span> was previously a collection of <span class="keyword">Character</span> values, similar to an array. Now, <span class="keyword">String</span> provides a <span class="keyword">characters</span> property that exposes a character collection view.</p><p>Why the change? Although it may seem natural to model a string as a collection of characters, the <span class="keyword">String</span> type behaves quite differently from collection types like <span class="keyword">Array</span>, <span class="keyword">Set</span>, or <span class="keyword">Dictionary</span>. This has always been true, but with the addition of protocol extensions to Swift 2 these differences made it necessary to make several fundamental changes.</p><h3>Different Than the Sum of Its Parts</h3><p>When you add an element to a collection, you expect that the collection will contain that element. That is, when you append a value to an array, the array then contains that value. The same applies to a dictionary or a set. However, when you append a combining mark character to a string, the contents of the string itself change.</p><p>Consider the string <span class="keyword">cafe</span>, which has four characters: <span class="keyword">c</span>, <span class="keyword">a</span>, <span class="keyword">f</span>, and <span class="keyword">e</span>:</p><a href="http://developer.apple.com/swift/blog/?id=30">[view code in blog]</a><p>If you append the combining acute accent character <span class="keyword">U+0301</span> <span class="keyword">¬¥</span> the string still has four characters, but the last character is now <span class="keyword">√©</span>:</p><a href="http://developer.apple.com/swift/blog/?id=30">[view code in blog]</a><p>The string‚Äôs <span class="keyword">characters</span> property does not contain the original lowercase <span class="keyword">e</span>, nor does it contain the combining acute accent <span class="keyword">¬¥</span> that was just appended. Instead, the string now contains a lowercase ‚Äúe‚Äù with acute accent <span class="keyword">√©</span>:</p><a href="http://developer.apple.com/swift/blog/?id=30">[view code in blog]</a><p>If we were to treat strings like any other collection, this result would be as surprising as adding <span class="keyword">UIColor.redColor()</span> and <span class="keyword">UIColor.greenColor()</span> to a set and the set then reporting that it contains <span class="keyword">UIColor.yellowColor()</span>.</p><h3>Judged by the Contents of Its Characters</h3><p>Another difference between strings and collections is the way they determine equality.</p><ul><li>Two arrays are equal only if both have the same count, and each pair of elements at corresponding indices are equal.</li><li>Two sets are equal only if both have the same count, and each element contained in the first set is also contained in the second.</li><li>Two dictionaries are equal only if they have the same set of key, value pairs.</li></ul><p>However, <span class="keyword">String</span> determines equality based on being <em>canonically equivalent</em>. Characters are canonically equivalent if they have the same linguistic meaning and appearance, even if they are composed from different Unicode scalars behind the scenes.</p><p>Consider the Korean writing system, which consists of 24 letters, or <em>Jamo</em>, representing individual consonants and vowels. When written out these letters are combined into characters for each syllable. For example, the character ‚ÄúÍ∞Ä‚Äù ([ga]) is composed of the letters ‚Äú·ÑÄ‚Äù ([g]) and ‚Äú·Ö°‚Äù [a]. In Swift, strings are considered equal regardless of whether they are constructed from decomposed or precomposed character sequences:</p><a href="http://developer.apple.com/swift/blog/?id=30">[view code in blog]</a><p>Again, this behavior differs greatly from any of Swift‚Äôs collection types. It would be as surprising as an array with values <span class="keyword">üêü</span> and <span class="keyword">üçö</span> being considered equal to <span class="keyword">üç£</span>.</p><h3>Depends on Your Point of View</h3><p>Strings are not collections. But they do provide <em>views</em> that conform to <span class="keyword">CollectionType</span>:</p><ul><li><span class="keyword">characters</span> is a collection of <span class="keyword">Character</span> values, or <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Strings/Articles/stringsClusters.html">extended grapheme clusters</a>.</li><li><span class="keyword">unicodeScalars</span> is a collection of <a href="http://www.unicode.org/glossary/#unicode_scalar_value">Unicode scalar values</a>.</li><li><span class="keyword">utf8</span> is a collection of <a href="http://www.unicode.org/glossary/#UTF_8">UTF&amp;#8211;8</a> code units.</li><li><span class="keyword">utf16</span> is a collection of <a href="http://www.unicode.org/glossary/#UTF_16">UTF&amp;#8211;16</a> code units.</li></ul><p>If we take the previous example of the word ‚Äúcaf√©‚Äù, comprised of the decomposed characters [ c, a, f, e ] and [ ¬¥ ], here's what the various string views would consist of:</p><img alt="" src="https://devimages.apple.com.edgekey.net/swift/blog/images/swift-string-views.png" width="650" height="312"><ul><li>The <span class="keyword">characters</span> property segments the text into <em>extended grapheme clusters</em>, which are an approximation of user-perceived characters (in this case: c, a, f, and √©). Because a string must iterate through each of its positions within the overall string (each position is called a code point) in order to determine character boundaries, accessing this property is executed in linear <span class="keyword">O(n)</span> time. When processing strings that contain human-readable text, high-level locale-sensitive Unicode algorithms, such as those used by the <span class="keyword">localizedStandardCompare(_:)</span> method and the <span class="keyword">localizedLowercaseString</span> property, should be preferred to character-by-character processing.</li><li>The <span class="keyword">unicodeScalars</span> property exposes the underlying scalar values stored in the string. If the original string were created with the precomposed character <span class="keyword">√©</span> instead of the decomposed <span class="keyword">e</span> + <span class="keyword">¬¥</span>, this would be reflected by the Unicode scalars view. Use this API when you are performing low-level manipulation of character data.</li><li>The <span class="keyword">utf8</span> and <span class="keyword">utf16</span> properties provide code points for the UTF‚Äì8 and UTF‚Äì16 representations, respectively. These values correspond to the actual bytes written to a file when translated to and from a particular encoding. UTF-8 code units are used by many POSIX string processing APIs, whereas UTF-16 code units are used throughout Cocoa &amp; Cocoa Touch to represent string lengths and offsets.</li></ul><p>For more information about working with Strings and Characters in Swift, read <a href="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/StringsAndCharacters.html#//apple_ref/doc/uid/TP40014097-CH7-ID285">The Swift Programming Language</a> and the <a href="https://developer.apple.com/library/prerelease/ios//documentation/Swift/Reference/Swift_String_Structure/index.html#//apple_ref/swift/struct/s:SS">Swift Standard Library Reference</a>.</p>]]></content:encoded>
</item>
<item>
<title>Swift 2.0</title>
<link>http://developer.apple.com/swift/blog/?id=29</link>
<guid>http://developer.apple.com/swift/blog/?id=29</guid>
<description> Today at WWDC, we announced  Swift 2.0 .  This new version has even better performance, a new error handling API, and first-class support for availability checking. And platform APIs feel even more natural in Swift with enhancements to the  Apple SDKs .  Open Source  In addition to new features, the big news is that Apple will be making Swift open source later this year.  We are all incredibly excited about this, and look forward to giving you a lot more information as the open source release gets nearer.  Here is what we can tell you so far:   Swift source code will be released under an OSI-approved permissive license.  Contributions from the community will be accepted ‚Äî and encouraged.  At launch we intend to contribute ports for  OS X , iOS, and Linux.  Source code will include the Swift compiler and standard library.  We think it would be amazing for Swift to be on all your favorite platforms.   We are excited about the opportunities an open source Swift creates for our industry.  Baked-in safety features combined with excellent speed mean it has the chance to dramatically improve software versus using C-based languages.  Swift is packed with modern features, it‚Äôs fun to write, and we believe it will get used in a lot of places.  Together, we have an exciting road ahead.  New Features   Swift 2.0  also includes a lot of new language features and refinements. Expect to see blog posts exploring the features in more depth, and be sure to watch for the WWDC sessions covering these topics all this week. A few of the new features include:   Error handling model:  The new error handling model in  Swift 2.0  will instantly feel natural, with familiar   try ,  throw , and  catch  keywords.  Best of all, it was designed to work perfectly with the  Apple SDKs  and  NSError .  In fact,  NSError  conforms to a Swift‚Äôs  ErrorType .  You‚Äôll definitely want to watch the WWDC session on What‚Äôs New in Swift to hear more about it.   Availability:  Using the latest SDKs ensures you get access to new features and information about platform changes.  But sometimes you still need to target an older OS, and Swift makes doing so much easier and safer.  The Swift compiler now shows an error when you use an API that is too new for your target OS, and  #available  blocks can safely wrap lines of code to only run when on the right OS versions.   Protocol extensions:  Swift is very focused on protocol-oriented development ‚Äî there‚Äôs even a session on the topic at  WWDC 2015 .   Swift 2.0  adds protocol extensions, and the standard library itself uses them extensively.  Where you used to use global functions,  Swift 2.0  now adds methods to common types so functions chain naturally, and your code is much more readable.   Swift-er SDKs:   Swift 2  works even better with the  Apple SDKs , thanks in part to two new features in Objective-C:  nullability annotations and generics.  The SDKs have been updated to annotate API that cannot return  nil  so you don‚Äôt need to use optionals as often.  And with a true generics system employed by the SDKs you can more often preserve detailed type information in your  Swift 2  code.  Learn more  This is just a taste of what‚Äôs new in  Swift 2 .  You can download the latest version of  The Swift Programming Language  from the  iBooks Store , and be sure to watch the WWDC sessions live streamed and on video throughout the week.  And to read more, visit  http://developer.apple.com/swift  </description>
<pubDate>Mon, 08 Jun 2015 12:00:00 PDT</pubDate>
<content:encoded><![CDATA[<p>Today at WWDC, we announced <span class="nowrap">Swift 2.0</span>.  This new version has even better performance, a new error handling API, and first-class support for availability checking. And platform APIs feel even more natural in Swift with enhancements to the <span class="nowrap">Apple SDKs</span>.</p><h3>Open Source</h3><p>In addition to new features, the big news is that Apple will be making Swift open source later this year.  We are all incredibly excited about this, and look forward to giving you a lot more information as the open source release gets nearer.  Here is what we can tell you so far:</p><ul><li>Swift source code will be released under an OSI-approved permissive license.</li><li>Contributions from the community will be accepted ‚Äî and encouraged.</li><li>At launch we intend to contribute ports for <span class="nowrap">OS X</span>, iOS, and Linux.</li><li>Source code will include the Swift compiler and standard library.</li><li>We think it would be amazing for Swift to be on all your favorite platforms.</li></ul><p>We are excited about the opportunities an open source Swift creates for our industry.  Baked-in safety features combined with excellent speed mean it has the chance to dramatically improve software versus using C-based languages.  Swift is packed with modern features, it‚Äôs fun to write, and we believe it will get used in a lot of places.  Together, we have an exciting road ahead.</p><h3>New Features</h3><p><span class="nowrap">Swift 2.0</span> also includes a lot of new language features and refinements. Expect to see blog posts exploring the features in more depth, and be sure to watch for the WWDC sessions covering these topics all this week. A few of the new features include:</p><p><strong>Error handling model: </strong>The new error handling model in <span class="nowrap">Swift 2.0</span> will instantly feel natural, with familiar  <span class="keyword">try</span>, <span class="keyword">throw</span>, and <span class="keyword">catch</span> keywords.  Best of all, it was designed to work perfectly with the <span class="nowrap">Apple SDKs</span> and <span class="keyword">NSError</span>.  In fact, <span class="keyword">NSError</span> conforms to a Swift‚Äôs <span class="keyword">ErrorType</span>.  You‚Äôll definitely want to watch the WWDC session on What‚Äôs New in Swift to hear more about it.</p><p><strong>Availability: </strong>Using the latest SDKs ensures you get access to new features and information about platform changes.  But sometimes you still need to target an older OS, and Swift makes doing so much easier and safer.  The Swift compiler now shows an error when you use an API that is too new for your target OS, and <span class="keyword">#available</span> blocks can safely wrap lines of code to only run when on the right OS versions.</p><p><strong>Protocol extensions: </strong>Swift is very focused on protocol-oriented development ‚Äî there‚Äôs even a session on the topic at <span class="nowrap">WWDC 2015</span>.  <span class="nowrap">Swift 2.0</span> adds protocol extensions, and the standard library itself uses them extensively.  Where you used to use global functions, <span class="nowrap">Swift 2.0</span> now adds methods to common types so functions chain naturally, and your code is much more readable.</p><p><strong>Swift-er SDKs: </strong><span class="nowrap">Swift 2</span> works even better with the <span class="nowrap">Apple SDKs</span>, thanks in part to two new features in Objective-C:  nullability annotations and generics.  The SDKs have been updated to annotate API that cannot return <span class="keyword">nil</span> so you don‚Äôt need to use optionals as often.  And with a true generics system employed by the SDKs you can more often preserve detailed type information in your <span class="nowrap">Swift 2</span> code.</p><h3>Learn more</h3><p>This is just a taste of what‚Äôs new in <span class="nowrap">Swift 2</span>.  You can download the latest version of <em>The Swift Programming Language</em> from the <span class="nowrap">iBooks Store</span>, and be sure to watch the WWDC sessions live streamed and on video throughout the week.  And to read more, visit <a href="http://developer.apple.com/swift">http://developer.apple.com/swift</a></p>]]></content:encoded>
</item>
<item>
<title>Memory Safety: Ensuring Values are Defined Before Use</title>
<link>http://developer.apple.com/swift/blog/?id=28</link>
<guid>http://developer.apple.com/swift/blog/?id=28</guid>
<description>  A primary focus when designing Swift was improving the memory safety of the programming model. There are a lot of aspects of memory safety, so this post will start slow and cover a simple case: how to make sure that variables are initialized with a value before they are used.   The Swift Approach  Variables are considered ‚Äúsafe‚Äù when the developer can be sure that there will be a valid value ready to use before any code tries to access it. Languages take several different approaches to this kind of safety. Some, like C, put the burden entirely on the programmer to employ safe programming techniques ‚Äî a powerful approach, but riddled with risk. C++ and Objective-C improve the situation by enforcing some mandatory patterns, while other languages take extreme measures by requiring initialization at the point of definition.  The primary technique employed by Swift is to use our advanced compiler to perform dataflow analysis of the code. The compiler then enforces that each variable was initialized before it is used, a strategy known as  Definitive Initialization . Languages such as Java and C# (among others) are known to also employ this technique. Swift uses an extended version of this approach for a broad range of variables.  Note: The bottom of this post includes information about other techniques, most of which Swift also employs to some degree.  Definitive Initialization of Local Variables  Swift applies the rules of definitive initialization in many contexts, but the simplest use is for local variables. Definitive initialization gives you more flexibility than a ‚Äúimplicit default initialization‚Äù rule ( see below ) would, because it allows you to write this code:  [view code in blog]  Here the compiler can prove that both sides of the  if  statement are guaranteed to initialize  myInstance , which proves that the method call can‚Äôt use uninitialized memory.  Definitive initialization is a powerful approach, but it is only really useful if it is reliable and predictable. One place that this can lead to surprise is when you have more complex control flow, for example like this:  [view code in blog]  In this case, the compiler will tell you: ‚ÄúVariable  myInstance  used before initialized‚Äù on the call to  printIt() . This is because the compiler does not track the correlation between the predicates in the  if  conditions. While we could teach the compiler to handle individual specific cases like this one, it is impossible to handle all cases (doing so is equivalent to the  halting problem ) so we opted to keep the compiler‚Äôs rules simple and predictable.  Swift makes it extremely easy to initialize a variable. In fact, it is shorter to declare a variable as  var x = 0  giving the variable the initial value  0  than it is to declare the uninitialized variable  var x : Int . Swift favors explicitness of initialization whenever possible. There are also more powerful ways to initialize a variable when the situation calls for it using  init() . For comprehensive information you can read the chapter " Initialization " in The Swift Programming Language.  Other Approaches  In addition to definitive initialization, Swift also employs additional approaches in focused areas of the language. You may have used these techniques in other languages, so we wanted to cover them briefly in this post. Each has some drawbacks, so they aren‚Äôt used as Swift‚Äôs primary approach:   Leave safety to the programmer:  Given the prevalence of C, it was important to understand the pros and cons of simply leaving safety up to the developer. Unfortunately, use of an uninitialized value in C produces  undefined behavior , often leading to runtime explosions. C relies on the programmer to never make a mistake. Given that our goal was to make Swift ‚Äúsafe by default,‚Äù this approach was quickly discarded for general use. However, APIs like  UnsafePointer  allow you to explicitly opt-in to unsafety when this power is absolutely necessary.   Implicit Default Initialization:  Values could be ensured to be safe by having the compiler implicitly initialize them, for example by setting a ‚Äúzero value‚Äù like Objective-C does for instance variables, or by running default initializers like in C++. We explored this approach in depth, but ultimately decided against its broad use because:    This doesn‚Äôt work for cases that have no legal initial value, e.g. protocols with no  init()  requirement, and non-nullable references to classes, which are pervasive in Swift.    Even for primitive types like integers  0  is often the wrong value. That‚Äôs one reason setting the initial value is so easy in Swift. This also makes the code more obvious for those who will maintain it, as well as defining away a potential error of omission, e.g. when  -1  is the right sentinel to use.    Note that default initialization to  nil  is clearly the right answer for nullable values so all values of  Optional  and  ImplicitlyUnwrappedOptional  type automatically initialize to  nil  by default.   Require an initializer at definition.  Put the burden on the developer to always provide an initial value at the time the variable is defined, meaning that  var x : Int  would be illegal without an initializer. While this is a common approach among functional languages, we considered this to be too heavy of a requirement because it enforces a very strict programming style, which gets in the way of expressing natural patterns. </description>
<pubDate>Fri, 24 Apr 2015 12:45:00 PDT</pubDate>
<content:encoded><![CDATA[ <p>A primary focus when designing Swift was improving the memory safety of the programming model. There are a lot of aspects of memory safety, so this post will start slow and cover a simple case: how to make sure that variables are initialized with a value before they are used.</p> <h3>The Swift Approach</h3><p>Variables are considered ‚Äúsafe‚Äù when the developer can be sure that there will be a valid value ready to use before any code tries to access it. Languages take several different approaches to this kind of safety. Some, like C, put the burden entirely on the programmer to employ safe programming techniques ‚Äî a powerful approach, but riddled with risk. C++ and Objective-C improve the situation by enforcing some mandatory patterns, while other languages take extreme measures by requiring initialization at the point of definition.</p><p>The primary technique employed by Swift is to use our advanced compiler to perform dataflow analysis of the code. The compiler then enforces that each variable was initialized before it is used, a strategy known as <a href="http://en.wikipedia.org/wiki/Definite_assignment_analysis">Definitive Initialization</a>. Languages such as Java and C# (among others) are known to also employ this technique. Swift uses an extended version of this approach for a broad range of variables.</p><p class="update">Note: The bottom of this post includes information about other techniques, most of which Swift also employs to some degree.</p><h3>Definitive Initialization of Local Variables</h3><p>Swift applies the rules of definitive initialization in many contexts, but the simplest use is for local variables. Definitive initialization gives you more flexibility than a ‚Äúimplicit default initialization‚Äù rule (<em>see below</em>) would, because it allows you to write this code:</p><a href="http://developer.apple.com/swift/blog/?id=28">[view code in blog]</a><p>Here the compiler can prove that both sides of the <span class="keyword">if</span> statement are guaranteed to initialize <span class="keyword">myInstance</span>, which proves that the method call can‚Äôt use uninitialized memory.</p><p>Definitive initialization is a powerful approach, but it is only really useful if it is reliable and predictable. One place that this can lead to surprise is when you have more complex control flow, for example like this:</p><a href="http://developer.apple.com/swift/blog/?id=28">[view code in blog]</a><p>In this case, the compiler will tell you: ‚ÄúVariable <strong>myInstance</strong> used before initialized‚Äù on the call to <span class="keyword">printIt()</span>. This is because the compiler does not track the correlation between the predicates in the <span class="keyword">if</span> conditions. While we could teach the compiler to handle individual specific cases like this one, it is impossible to handle all cases (doing so is equivalent to the <a href="http://en.wikipedia.org/wiki/Halting_problem">halting problem</a>) so we opted to keep the compiler‚Äôs rules simple and predictable.</p><p>Swift makes it extremely easy to initialize a variable. In fact, it is shorter to declare a variable as <span class="keyword">var x = 0</span> giving the variable the initial value <span class="keyword">0</span> than it is to declare the uninitialized variable <span class="keyword">var x : Int</span>. Swift favors explicitness of initialization whenever possible. There are also more powerful ways to initialize a variable when the situation calls for it using <span class="keyword">init()</span>. For comprehensive information you can read the chapter "<a href="https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html">Initialization</a>" in The Swift Programming Language.</p><h3>Other Approaches</h3><p>In addition to definitive initialization, Swift also employs additional approaches in focused areas of the language. You may have used these techniques in other languages, so we wanted to cover them briefly in this post. Each has some drawbacks, so they aren‚Äôt used as Swift‚Äôs primary approach:</p><p><strong>Leave safety to the programmer:</strong> Given the prevalence of C, it was important to understand the pros and cons of simply leaving safety up to the developer. Unfortunately, use of an uninitialized value in C produces <a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html">undefined behavior</a>, often leading to runtime explosions. C relies on the programmer to never make a mistake. Given that our goal was to make Swift ‚Äúsafe by default,‚Äù this approach was quickly discarded for general use. However, APIs like <span class="keyword">UnsafePointer</span> allow you to explicitly opt-in to unsafety when this power is absolutely necessary.</p><p><strong>Implicit Default Initialization:</strong> Values could be ensured to be safe by having the compiler implicitly initialize them, for example by setting a ‚Äúzero value‚Äù like Objective-C does for instance variables, or by running default initializers like in C++. We explored this approach in depth, but ultimately decided against its broad use because:</p><ul><li><p>This doesn‚Äôt work for cases that have no legal initial value, e.g. protocols with no <span class="keyword">init()</span> requirement, and non-nullable references to classes, which are pervasive in Swift.</p></li><li><p>Even for primitive types like integers <span class="keyword">0</span> is often the wrong value. That‚Äôs one reason setting the initial value is so easy in Swift. This also makes the code more obvious for those who will maintain it, as well as defining away a potential error of omission, e.g. when <span class="keyword">-1</span> is the right sentinel to use.</p></li></ul><p>Note that default initialization to <span class="keyword">nil</span> is clearly the right answer for nullable values so all values of <span class="keyword">Optional</span> and <span class="keyword">ImplicitlyUnwrappedOptional</span> type automatically initialize to <span class="keyword">nil</span> by default.</p><p><strong>Require an initializer at definition.</strong> Put the burden on the developer to always provide an initial value at the time the variable is defined, meaning that <span class="keyword">var x : Int</span> would be illegal without an initializer. While this is a common approach among functional languages, we considered this to be too heavy of a requirement because it enforces a very strict programming style, which gets in the way of expressing natural patterns.</p>]]></content:encoded>
</item>
<item>
<title>Increasing Performance by Reducing Dynamic Dispatch</title>
<link>http://developer.apple.com/swift/blog/?id=27</link>
<guid>http://developer.apple.com/swift/blog/?id=27</guid>
<description> Like many other languages, Swift allows a class to override methods and properties declared in its superclasses. This means that the program has to determine at runtime which method or property is being referred to and then perform an indirect call or indirect access. This technique, called  dynamic dispatch , increases language expressivity at the cost of a constant amount of runtime overhead for each indirect usage. In performance sensitive code such overhead is often undesirable. This blog post showcases three ways to improve performance by eliminating such dynamism:  final ,  private , and Whole Module Optimization.  Consider the following example:  [view code in blog]  As written, the compiler will emit a dynamically dispatched call to:   Call  update  on  p .  Call  updatePoint  on  p .  Get the property  point  tuple of p.  Get the property  velocity  of p.   This might not be what you would expect when looking at this code. The dynamic calls are necessary because a subclass of  ParticleModel  might override  point  or  velocity  with a computed property or override  updatePoint()  or  update()  with new implementations.  In Swift, dynamic dispatch calls are implemented by looking up a function from a method table and then performing an indirect call. This is slower than performing a direct call. Additionally, indirect calls also prevent many compiler optimizations, making the indirect call even more expensive. In performance critical code there are techniques you can use to restrict this dynamic behavior when it isn‚Äôt needed to improve performance.  Use  final  when you know that a declaration does not need to be overridden.  The  final  keyword is a restriction on a class, method, or property that indicates that the declaration cannot be overridden. This allows the compiler to safely elide dynamic dispatch indirection. For instance, in the following  point  and  velocity  will be accessed directly through a load from the object‚Äôs stored property and  updatePoint()  will be called via a direct function call. On the other hand,  update()  will still be called via dynamic dispatch, allowing for subclasses to override  update()  with customized functionality.  [view code in blog]  It is possible to mark an entire class as  final  by attaching the attribute to the class itself. This forbids subclassing the class, implying that all functions and properties of the class are  final  as well.  [view code in blog]  Infer  final  on declarations referenced in one file by applying the  private  keyword.  Applying the  private  keyword to a declaration restricts the visibility of the declaration to the current file. This allows the compiler to find all potentially overriding declarations. The absence of any such overriding declarations enables the compiler to infer the  final  keyword automatically and remove indirect calls for methods and property accesses.  Assuming there is no class overriding  ParticleModel  in the current file, the compiler can replace all dynamically dispatched calls to private declarations with direct calls.  [view code in blog]  As in the previous example,  point  and  velocity  are accessed directly and  updatePoint()  is called directly. Again,  update()  will be invoked indirectly due to  update()  not being  private .  Just like with  final , it is possible to apply the  private  attribute to the class declaration itself causing the class to be  private  and thus all of the properties and methods of the class as well.  [view code in blog]  Use Whole Module Optimization to infer  final  on  internal  declarations.  Declarations with  internal  access (the default if nothing is declared) are only visible within the module where they are declared. Because Swift normally compiles the files that make up a module separately, the compiler cannot ascertain whether or not an  internal  declaration is overridden in a different file. However, if Whole Module Optimization is enabled, all of the module is compiled together at the same time. This allows the compiler to make inferences about the entire module together and infer  final  on declarations with  internal  if there are no visible overrides.  Let‚Äôs go back to the original code snippet, this time adding some extra  public  keywords to  ParticleModel .  [view code in blog]  When compiling this snippet with Whole Module Optimization the compiler can infer  final  on the properties  point ,  velocity , and the method call  updatePoint() . In contrast, it can not be inferred that  update()  is  final  since  update()  has public access. </description>
<pubDate>Thu, 09 Apr 2015 09:30:00 PDT</pubDate>
<content:encoded><![CDATA[<p>Like many other languages, Swift allows a class to override methods and properties declared in its superclasses. This means that the program has to determine at runtime which method or property is being referred to and then perform an indirect call or indirect access. This technique, called <em>dynamic dispatch</em>, increases language expressivity at the cost of a constant amount of runtime overhead for each indirect usage. In performance sensitive code such overhead is often undesirable. This blog post showcases three ways to improve performance by eliminating such dynamism: <span class="keyword">final</span>, <span class="keyword">private</span>, and Whole Module Optimization.</p><p>Consider the following example:</p><a href="http://developer.apple.com/swift/blog/?id=27">[view code in blog]</a><p>As written, the compiler will emit a dynamically dispatched call to:</p><ol><li>Call <span class="keyword">update</span> on <span class="keyword">p</span>.</li><li>Call <span class="keyword">updatePoint</span> on <span class="keyword">p</span>.</li><li>Get the property <span class="keyword">point</span> tuple of p.</li><li>Get the property <span class="keyword">velocity</span> of p.</li></ol><p>This might not be what you would expect when looking at this code. The dynamic calls are necessary because a subclass of <span class="keyword">ParticleModel</span> might override <span class="keyword">point</span> or <span class="keyword">velocity</span> with a computed property or override <span class="keyword">updatePoint()</span> or <span class="keyword">update()</span> with new implementations.</p><p>In Swift, dynamic dispatch calls are implemented by looking up a function from a method table and then performing an indirect call. This is slower than performing a direct call. Additionally, indirect calls also prevent many compiler optimizations, making the indirect call even more expensive. In performance critical code there are techniques you can use to restrict this dynamic behavior when it isn‚Äôt needed to improve performance.</p><h3>Use <span class="menlo">final</span> when you know that a declaration does not need to be overridden.</h3><p>The <span class="keyword">final</span> keyword is a restriction on a class, method, or property that indicates that the declaration cannot be overridden. This allows the compiler to safely elide dynamic dispatch indirection. For instance, in the following <span class="keyword">point</span> and <span class="keyword">velocity</span> will be accessed directly through a load from the object‚Äôs stored property and <span class="keyword">updatePoint()</span> will be called via a direct function call. On the other hand, <span class="keyword">update()</span> will still be called via dynamic dispatch, allowing for subclasses to override <span class="keyword">update()</span> with customized functionality.</p><a href="http://developer.apple.com/swift/blog/?id=27">[view code in blog]</a><p>It is possible to mark an entire class as <span class="keyword">final</span> by attaching the attribute to the class itself. This forbids subclassing the class, implying that all functions and properties of the class are <span class="keyword">final</span> as well.</p><a href="http://developer.apple.com/swift/blog/?id=27">[view code in blog]</a><h3>Infer <span class="menlo">final</span> on declarations referenced in one file by applying the <span class="menlo">private</span> keyword.</h3><p>Applying the <span class="keyword">private</span> keyword to a declaration restricts the visibility of the declaration to the current file. This allows the compiler to find all potentially overriding declarations. The absence of any such overriding declarations enables the compiler to infer the <span class="keyword">final</span> keyword automatically and remove indirect calls for methods and property accesses.</p><p>Assuming there is no class overriding <span class="keyword">ParticleModel</span> in the current file, the compiler can replace all dynamically dispatched calls to private declarations with direct calls.</p><a href="http://developer.apple.com/swift/blog/?id=27">[view code in blog]</a><p>As in the previous example, <span class="keyword">point</span> and <span class="keyword">velocity</span> are accessed directly and <span class="keyword">updatePoint()</span> is called directly. Again, <span class="keyword">update()</span> will be invoked indirectly due to <span class="keyword">update()</span> not being <span class="keyword">private</span>.</p><p>Just like with <span class="keyword">final</span>, it is possible to apply the <span class="keyword">private</span> attribute to the class declaration itself causing the class to be <span class="keyword">private</span> and thus all of the properties and methods of the class as well.</p><a href="http://developer.apple.com/swift/blog/?id=27">[view code in blog]</a><h3>Use Whole Module Optimization to infer <span class="menlo">final</span> on <span class="menlo">internal</span> declarations.</h3><p>Declarations with <span class="keyword">internal</span> access (the default if nothing is declared) are only visible within the module where they are declared. Because Swift normally compiles the files that make up a module separately, the compiler cannot ascertain whether or not an <span class="keyword">internal</span> declaration is overridden in a different file. However, if Whole Module Optimization is enabled, all of the module is compiled together at the same time. This allows the compiler to make inferences about the entire module together and infer <span class="keyword">final</span> on declarations with <span class="keyword">internal</span> if there are no visible overrides.</p><p>Let‚Äôs go back to the original code snippet, this time adding some extra <span class="keyword">public</span> keywords to <span class="keyword">ParticleModel</span>.</p><a href="http://developer.apple.com/swift/blog/?id=27">[view code in blog]</a><p>When compiling this snippet with Whole Module Optimization the compiler can infer <span class="keyword">final</span> on the properties <span class="keyword">point</span>, <span class="keyword">velocity</span>, and the method call <span class="keyword">updatePoint()</span>. In contrast, it can not be inferred that <span class="keyword">update()</span> is <span class="keyword">final</span> since <span class="keyword">update()</span> has public access.</p>]]></content:encoded>
</item>
<item>
<title>New Playgrounds Part 2 - Sources</title>
<link>http://developer.apple.com/swift/blog/?id=26</link>
<guid>http://developer.apple.com/swift/blog/?id=26</guid>
<description> Xcode 6.3 beta 3 adds even more to the new playgrounds format introduced in the last beta. The Xcode Project Navigator now lets you easily access a new Sources folder that includes additional Swift code, as well as the Resources folder.  Playgrounds and the Project Navigator  Playgrounds are now represented within Xcode as a bundle with a disclosure triangle that reveals Resources and Sources folders when clicked. These folders contain additional content that is easily accessible from your playground‚Äôs main Swift code. To see these folders, choose View > Navigators > Show Project Navigator (or just hit Command-1).  It is easy to drag-and-drop images and other content into the Resources folder. You may want to go back and look at the DemoNewFormat.playground file from the  previous blog post  for another example of how these resources are stored and used (using the latest Xcode 6.3 beta 3).  Sources Folder  The Sources folder is new in Xcode 6.3 beta 3. This folder contains additional Swift source files that your main playground code can easily access. Putting extra supporting  .swift  files into the Sources folder makes it easy to keep your playground clean and readable. Code in the Sources folder also gains a big performance benefit because this code is compiled once, and is not run in the same interactive manner as the main playground code. This allows curriculum and sample code authors to create even more interactive and exciting playgrounds while the visible code remains approachable for the reader.  Mandelbrot Example  Here‚Äôs an example playground that calculates the complex and beautiful Mandelbrot set. This playground uses the Sources folder to demonstrate the power and added performance that it enables. To see the inner workings of  this playground , examine the code within the Sources folder.    </description>
<pubDate>Tue, 17 Mar 2015 15:10:00 PDT</pubDate>
<content:encoded><![CDATA[<p>Xcode 6.3 beta 3 adds even more to the new playgrounds format introduced in the last beta. The Xcode Project Navigator now lets you easily access a new Sources folder that includes additional Swift code, as well as the Resources folder.</p><h3>Playgrounds and the Project Navigator</h3><p>Playgrounds are now represented within Xcode as a bundle with a disclosure triangle that reveals Resources and Sources folders when clicked. These folders contain additional content that is easily accessible from your playground‚Äôs main Swift code. To see these folders, choose View > Navigators > Show Project Navigator (or just hit Command-1).</p><p>It is easy to drag-and-drop images and other content into the Resources folder. You may want to go back and look at the DemoNewFormat.playground file from the <a href="https://developer.apple.com/swift/blog/?id=24">previous blog post</a> for another example of how these resources are stored and used (using the latest Xcode 6.3 beta 3).</p><h3>Sources Folder</h3><p>The Sources folder is new in Xcode 6.3 beta 3. This folder contains additional Swift source files that your main playground code can easily access. Putting extra supporting <em>.swift</em> files into the Sources folder makes it easy to keep your playground clean and readable. Code in the Sources folder also gains a big performance benefit because this code is compiled once, and is not run in the same interactive manner as the main playground code. This allows curriculum and sample code authors to create even more interactive and exciting playgrounds while the visible code remains approachable for the reader.</p><h3>Mandelbrot Example</h3><p>Here‚Äôs an example playground that calculates the complex and beautiful Mandelbrot set. This playground uses the Sources folder to demonstrate the power and added performance that it enables. To see the inner workings of <a href="http://developer.apple.com/swift/blog/downloads/Mandelbrot.zip">this playground</a>, examine the code within the Sources folder.</p><p><img alt="Mandlebrot Screenshot" src="https://devimages.apple.com.edgekey.net/swift/blog/images/mandelbrot-screen.png" width="800" height="1274" /></p>]]></content:encoded>
</item>
<item>
<title>Nullability and Objective-C</title>
<link>http://developer.apple.com/swift/blog/?id=25</link>
<guid>http://developer.apple.com/swift/blog/?id=25</guid>
<description> UPDATE: This post was updated to use the new _Nullable syntax in Xcode 7.  One of the great things about Swift is that it transparently interoperates with Objective-C code, both existing frameworks written in Objective-C and code in your app. However, in Swift there‚Äôs a strong distinction between optional and non-optional references, e.g.  NSView  vs.  NSView? , while Objective-C represents boths of these two types as  NSView * . Because the Swift compiler can‚Äôt be sure whether a particular  NSView *  is optional or not, the type is brought into Swift as an implicitly unwrapped optional,  NSView! .  In previous Xcode releases, some Apple frameworks had been specially audited so that their API would show up with proper Swift optionals. Xcode 6.3 supports this for your own code with a new Objective-C language feature:  nullability annotations .  The Core:  _Nullable  and  _Nonnull   At the core of this feature we have two new type annotations:  _Nullable  and  _Nonnull . As you might expect, a  _Nullable  pointer may have a  NULL  or  nil  value, while a  _Nonnull  one should not. The compiler will tell you if you try to break the rules.  [view code in blog]  You can use  _Nullable  and  _Nonnull  almost anywhere you can use the normal C  const  keyword, though of course they have to apply to a pointer type. However, in the common case there‚Äôs a much nicer way to write these annotations: within method declarations you can use the non-underscored forms  nullable  and  nonnull  immediately after an open parenthesis, as long as the type is a simple object or block pointer.  [view code in blog]  And for properties, you can use the same non-underscored spelling by moving the annotation into the property attributes list.  [view code in blog]  The non-underscored forms are nicer than the underscored ones, but you‚Äôd still need to apply them to every type in your header. To make that job easier and to make your headers clearer, you‚Äôll want to use audited regions.  Audited Regions  To ease adoption of the new annotations, you can mark certain regions of your Objective-C header files as  audited for nullability . Within these regions, any simple pointer type will be assumed to be  nonnull . This collapses our earlier example down into something much simpler.  [view code in blog]  For safety, there are a few exceptions to this rule:    typedef  types don‚Äôt usually have an inherent nullability‚Äîthey can easily be either nullable or non-nullable depending on the context. Therefore,  typedef  types are not assumed to be  nonnull , even within audited regions.  More complex pointer types like  id *  must be explicitly annotated. For example, to specify a non-nullable pointer to a nullable object reference, use  _Nullable id * _Nonnull .  The particular type  NSError **  is so often used to return errors via method parameters that it is always assumed to be a nullable pointer to a nullable  NSError  reference.   You can read more about this in the  Error Handling Programming Guide .  Compatibility  What if your Objective-C framework has existing code written against it? Is it safe to just change your types like this?  Yes, it is .   Existing compiled code that uses your framework will continue to work, i.e. the ABI does not change. This also means that existing code will not catch incorrect passing of  nil  at runtime.  Existing  source  code that uses your framework may get additional warnings for current uses of unsafe behavior at compile time when you move to the new Swift compiler.   nonnull  does not affect optimization. In particular, you can still check parameters marked  nonnull  to see if they are actually  nil  at runtime. This may be necessary for backwards-compatibility.   In general, you should look at  nullable  and  nonnull  roughly the way you currently use assertions or exceptions: violating the contract is a programmer error. In particular, return values are something you control, so you should never return  nil  for a non-nullable return type unless it is for backwards-compatibility.  This feature was first released in Xcode 6.3 with the keywords  __nullable  and  __nonnull . Due to potential conflicts with third-party libraries, we‚Äôve changed them in Xcode 7 to the _Nullable and _Nonnull you see here. However, for compatibility with Xcode 6.3 we‚Äôve predefined macros  __nullable  and  __nonnull  to expand to the new names.  Back to Swift  Now that we‚Äôve added nullability annotations to our Objective-C header, let‚Äôs use it from Swift:  Before annotating our Objective-C:  [view code in blog]  After annotations:  [view code in blog]  The Swift code is now cleaner. It‚Äôs a subtle change, but it will make using your framework more pleasant.  Nullability annotations for C and Objective-C are available starting in Xcode 6.3. For more information, see the  Xcode 6.3 Release Notes . </description>
<pubDate>Thu, 12 Mar 2015 13:00:00 PDT</pubDate>
<content:encoded><![CDATA[<p class="update">UPDATE: This post was updated to use the new _Nullable syntax in Xcode 7.</p><p>One of the great things about Swift is that it transparently interoperates with Objective-C code, both existing frameworks written in Objective-C and code in your app. However, in Swift there‚Äôs a strong distinction between optional and non-optional references, e.g. <span class="keyword">NSView</span> vs. <span class="keyword">NSView?</span>, while Objective-C represents boths of these two types as <span class="keyword">NSView *</span>. Because the Swift compiler can‚Äôt be sure whether a particular <span class="keyword">NSView *</span> is optional or not, the type is brought into Swift as an implicitly unwrapped optional, <span class="keyword">NSView!</span>.</p><p>In previous Xcode releases, some Apple frameworks had been specially audited so that their API would show up with proper Swift optionals. Xcode 6.3 supports this for your own code with a new Objective-C language feature: <em>nullability annotations</em>.</p><h3>The Core: <span class="menlo">_Nullable</span> and <span class="menlo">_Nonnull</span></h3><p>At the core of this feature we have two new type annotations: <span class="keyword">_Nullable</span> and <span class="keyword">_Nonnull</span>. As you might expect, a <span class="keyword">_Nullable</span> pointer may have a <span class="keyword">NULL</span> or <span class="keyword">nil</span> value, while a <span class="keyword">_Nonnull</span> one should not. The compiler will tell you if you try to break the rules.</p><a href="http://developer.apple.com/swift/blog/?id=25">[view code in blog]</a><p>You can use <span class="keyword">_Nullable</span> and <span class="keyword">_Nonnull</span> almost anywhere you can use the normal C <span class="keyword">const</span> keyword, though of course they have to apply to a pointer type. However, in the common case there‚Äôs a much nicer way to write these annotations: within method declarations you can use the non-underscored forms <span class="keyword">nullable</span> and <span class="keyword">nonnull</span> immediately after an open parenthesis, as long as the type is a simple object or block pointer.</p><a href="http://developer.apple.com/swift/blog/?id=25">[view code in blog]</a><p>And for properties, you can use the same non-underscored spelling by moving the annotation into the property attributes list.</p><a href="http://developer.apple.com/swift/blog/?id=25">[view code in blog]</a><p>The non-underscored forms are nicer than the underscored ones, but you‚Äôd still need to apply them to every type in your header. To make that job easier and to make your headers clearer, you‚Äôll want to use audited regions.</p><h3>Audited Regions</h3><p>To ease adoption of the new annotations, you can mark certain regions of your Objective-C header files as <em>audited for nullability</em>. Within these regions, any simple pointer type will be assumed to be <span class="keyword">nonnull</span>. This collapses our earlier example down into something much simpler.</p><a href="http://developer.apple.com/swift/blog/?id=25">[view code in blog]</a><p>For safety, there are a few exceptions to this rule:</p><ul><li><span class="keyword">typedef</span> types don‚Äôt usually have an inherent nullability‚Äîthey can easily be either nullable or non-nullable depending on the context. Therefore, <span class="keyword">typedef</span> types are not assumed to be <span class="keyword">nonnull</span>, even within audited regions.</li><li>More complex pointer types like <span class="keyword">id *</span> must be explicitly annotated. For example, to specify a non-nullable pointer to a nullable object reference, use <span class="keyword">_Nullable id * _Nonnull</span>.</li><li>The particular type <span class="keyword">NSError **</span> is so often used to return errors via method parameters that it is always assumed to be a nullable pointer to a nullable <span class="keyword">NSError</span> reference.</li></ul><p>You can read more about this in the <a href="http://developer.apple.com/go/?id=error-handling-cocoa">Error Handling Programming Guide</a>.</p><h3>Compatibility</h3><p>What if your Objective-C framework has existing code written against it? Is it safe to just change your types like this? <em>Yes, it is</em>.</p><ul><li>Existing compiled code that uses your framework will continue to work, i.e. the ABI does not change. This also means that existing code will not catch incorrect passing of <span class="keyword">nil</span> at runtime.</li><li>Existing <em>source</em> code that uses your framework may get additional warnings for current uses of unsafe behavior at compile time when you move to the new Swift compiler.</li><li><span class="keyword">nonnull</span> does not affect optimization. In particular, you can still check parameters marked <span class="keyword">nonnull</span> to see if they are actually <span class="keyword">nil</span> at runtime. This may be necessary for backwards-compatibility.</li></ul><p>In general, you should look at <span class="keyword">nullable</span> and <span class="keyword">nonnull</span> roughly the way you currently use assertions or exceptions: violating the contract is a programmer error. In particular, return values are something you control, so you should never return <span class="keyword">nil</span> for a non-nullable return type unless it is for backwards-compatibility.</p><p>This feature was first released in Xcode 6.3 with the keywords <span class="keyword">__nullable</span> and <span class="keyword">__nonnull</span>. Due to potential conflicts with third-party libraries, we‚Äôve changed them in Xcode 7 to the _Nullable and _Nonnull you see here. However, for compatibility with Xcode 6.3 we‚Äôve predefined macros <span class="keyword">__nullable</span> and <span class="keyword">__nonnull</span> to expand to the new names.</p><h3>Back to Swift</h3><p>Now that we‚Äôve added nullability annotations to our Objective-C header, let‚Äôs use it from Swift:</p><p>Before annotating our Objective-C:</p><a href="http://developer.apple.com/swift/blog/?id=25">[view code in blog]</a><p>After annotations:</p><a href="http://developer.apple.com/swift/blog/?id=25">[view code in blog]</a><p>The Swift code is now cleaner. It‚Äôs a subtle change, but it will make using your framework more pleasant.</p><p>Nullability annotations for C and Objective-C are available starting in Xcode 6.3. For more information, see the <a href="http://developer.apple.com/go/?id=xcode-6.3-beta-release-notes">Xcode 6.3 Release Notes</a>.</p>]]></content:encoded>
</item>
<item>
<title>New Playgrounds</title>
<link>http://developer.apple.com/swift/blog/?id=24</link>
<guid>http://developer.apple.com/swift/blog/?id=24</guid>
<description> Xcode 6.3 beta 2 includes significant improvements to Swift playgrounds, with great features for authors. It‚Äôs now even easier to create rich, interactive playgrounds ‚Äî perfect for documentation, tutorials, or samples to include with your projects.  The new playgrounds are especially useful for educators. You can insert rich instructional content with paragraph headings, diagrams, and links to additional material alongside the interactive Swift code.  New features in Xcode 6.3 playgrounds include the following:    Inline results  display the output of your Swift code within the main editor window. The results area can be resized and configured to show different views of the output.   Stylized text  is easy to add to your playground by adding special markup to your comments based on the familiar Markdown syntax. Some available styles are headings, bold, italic, lists, bullets, and links to external or bundled resources.   The Resources folder  bundles images and other content directly within the playground. These resources can be accessed from your Swift code or from the rich comments within the playground.  (Note: with Xcode 6.3 beta 2 use Show Package Contents in Finder to drag files into the playground‚Äôs Resources folder.)     The latest Xcode 6.3 beta  includes the new playgrounds authoring features. These features are still evolving, so be sure to read the  release notes  and  let us know  of any bugs you find.  Here is a demonstration playground  to get you started.  </description>
<pubDate>Tue, 24 Feb 2015 15:00:00 PST</pubDate>
<content:encoded><![CDATA[<p>Xcode 6.3 beta 2 includes significant improvements to Swift playgrounds, with great features for authors. It‚Äôs now even easier to create rich, interactive playgrounds ‚Äî perfect for documentation, tutorials, or samples to include with your projects.</p><p>The new playgrounds are especially useful for educators. You can insert rich instructional content with paragraph headings, diagrams, and links to additional material alongside the interactive Swift code.</p><p>New features in Xcode 6.3 playgrounds include the following:</p><ul><li><strong>Inline results</strong> display the output of your Swift code within the main editor window. The results area can be resized and configured to show different views of the output.</li><li><strong>Stylized text</strong> is easy to add to your playground by adding special markup to your comments based on the familiar Markdown syntax. Some available styles are headings, bold, italic, lists, bullets, and links to external or bundled resources.</li><li><strong>The Resources folder</strong> bundles images and other content directly within the playground. These resources can be accessed from your Swift code or from the rich comments within the playground. <em>(Note: with Xcode 6.3 beta 2 use Show Package Contents in Finder to drag files into the playground‚Äôs Resources folder.)</em></li></ul><p><a href="http://developer.apple.com/xcode/downloads/">The latest Xcode 6.3 beta</a> includes the new playgrounds authoring features. These features are still evolving, so be sure to read the <a href="https://developer.apple.com/devcenter/download.action?path=/Developer_Tools/Xcode_6.3_beta_2/Xcode_6.3_beta_2_Release_Notes.pdf">release notes</a> and <a href="https://bugreport.apple.com/">let us know</a> of any bugs you find. <a href="http://developer.apple.com/swift/blog/downloads/DemoNewFormat.zip">Here is a demonstration playground</a> to get you started.</p><img alt="Demo New Format Screenshot" src="https://devimages.apple.com.edgekey.net/swift/blog/images/DemoNewFormat.png" width="800" height="1334" />]]></content:encoded>
</item>
<item>
<title>The  as!  Operator</title>
<link>http://developer.apple.com/swift/blog/?id=23</link>
<guid>http://developer.apple.com/swift/blog/?id=23</guid>
<description> Prior to Swift 1.2, the  as  operator could be used to carry out two different kinds of conversion, depending on the type of expression being converted and the type it was being converted to:    Guaranteed conversion  of a value of one type to another, whose success can be verified by the Swift compiler. For example, upcasting (i.e., converting from a class to one of its superclasses) or specifying the type of a literal expression, (e.g.,  1 as Float ).   Forced conversion  of one value to another, whose safety cannot be guaranteed by the Swift compiler and which may cause a runtime trap. For example downcasting, converting from a class to one of its subclasses.   Swift 1.2 separates the notions of guaranteed conversion and forced conversion into two distinct operators. Guaranteed conversion is still performed with the  as  operator, but forced conversion now uses the  as!  operator. The  !  is meant to indicate that the conversion may fail. This way, you know at a glance which conversions may cause the program to crash.  The following example illustrates the change:  [view code in blog]  Note the analogy between the expression postfix operators  !  and  ?  and the conversion operators  as!  and  as? :  [view code in blog]  It may be easiest to remember the pattern for these operators in Swift as:  !  implies  ‚Äúthis might trap,‚Äù  while  ?  indicates  ‚Äúthis might be nil.‚Äù  </description>
<pubDate>Wed, 18 Feb 2015 15:00:00 PST</pubDate>
<content:encoded><![CDATA[<p>Prior to Swift 1.2, the <span class="keyword">as</span> operator could be used to carry out two different kinds of conversion, depending on the type of expression being converted and the type it was being converted to:</p><ul><li><strong>Guaranteed conversion</strong> of a value of one type to another, whose success can be verified by the Swift compiler. For example, upcasting (i.e., converting from a class to one of its superclasses) or specifying the type of a literal expression, (e.g., <span class="keyword">1 as Float</span>).</li><li><strong>Forced conversion</strong> of one value to another, whose safety cannot be guaranteed by the Swift compiler and which may cause a runtime trap. For example downcasting, converting from a class to one of its subclasses.</li></ul><p>Swift 1.2 separates the notions of guaranteed conversion and forced conversion into two distinct operators. Guaranteed conversion is still performed with the <span class="keyword">as</span> operator, but forced conversion now uses the <span class="keyword">as!</span> operator. The <span class="keyword">!</span> is meant to indicate that the conversion may fail. This way, you know at a glance which conversions may cause the program to crash.</p><p>The following example illustrates the change:</p><a href="http://developer.apple.com/swift/blog/?id=23">[view code in blog]</a><p>Note the analogy between the expression postfix operators <span class="keyword">!</span> and <span class="keyword">?</span> and the conversion operators <span class="keyword">as!</span> and <span class="keyword">as?</span>:</p><a href="http://developer.apple.com/swift/blog/?id=23">[view code in blog]</a><p>It may be easiest to remember the pattern for these operators in Swift as: <span class="keyword">!</span> implies <em>‚Äúthis might trap,‚Äù</em> while <span class="keyword">?</span> indicates <em>‚Äúthis might be nil.‚Äù</em></p>]]></content:encoded>
</item>
<item>
<title>Swift 1.2 and Xcode 6.3 beta</title>
<link>http://developer.apple.com/swift/blog/?id=22</link>
<guid>http://developer.apple.com/swift/blog/?id=22</guid>
<description> Today Swift 1.2 was released as part of Xcode 6.3 beta. This beta release includes a significantly enhanced Swift compiler, as well as new features in the Swift language itself. For the complete list of changes, read the  release notes . This blog post will focus on the highlights.  Compiler improvements  The Swift 1.2 compiler was engineered to be more stable and to improve performance in every way. These changes also provide a better experience when working with Swift in Xcode. Some of the most visible improvements include:    Incremental builds  ‚Äî Source files that haven‚Äôt changed will no longer be re-compiled by default, which will significantly improve build times for most common cases. Larger structural changes to your code may still require multiple files to be rebuilt.   Faster executables  ‚Äî Debug builds produce binaries that run considerably faster, and new optimizations deliver even better Release build performance.   Better compiler diagnostics  ‚Äî Clearer error and warning messages, along with new Fix-its, make it easier to write proper Swift 1.2 code.   Stability improvements  ‚Äî The most common compiler crashes have been fixed. You should also see fewer SourceKit warnings within the Xcode editor.   New language features  In Swift 1.2, the language has been further refined to ensure safe, predictable behavior. We also continue to improve the interaction between Swift and Objective-C. Some of the more notable changes include:     as!  for failable casts  ‚Äî Casts that can fail at runtime are now expressed with the new  as!  operator to make their potential for runtime failure clear to readers and maintainers of your code.   Nullability may now be expressed in Objective-C headers  ‚Äî New Objective-C extensions in Clang allow you to express the nullability of pointers and blocks in your Objective-C API. You can provide Objective-C frameworks that work great with Swift code, and improve your Swift experience when mixing and matching with Objective-C code in your own project.   Swift enums can now be exported to Objective-C using the  @objc  attribute  ‚Äî For example, the following Swift code:   [view code in blog]  imports into Objective-C as:  [view code in blog]     let  constants are now more powerful and consistent  ‚Äî The new rule is that a  let  constant must be initialized before use (like a  var ), and that it may only be initialized, not reassigned or mutated after initialization.   This enables patterns like:  [view code in blog]  This formerly required the use of a  var  even though there is no mutation taking place. Properties have been folded into this model to simplify their semantics in initializers as well.    More powerful optional unwrapping with  if let   ‚Äî The  if let  construct can now unwrap multiple optionals at once, as well as include intervening boolean conditions. This lets you express conditional control flow without unnecessary nesting.   New native Set data structure  ‚Äî An unordered collection of unique elements that bridges with  NSSet  and provides value semantics like  Array  and  Dictionary .   Conclusion  We appreciate all of the bugs you have filed, and expect that many of the most common issues have been fixed in this beta. Swift 1.2 is a major step forward for both the language and the tools. It does include some source-incompatible changes that require updates to your code, so Xcode 6.3 includes a migrator to help automate the process. To begin the migration, click the Edit menu, then choose Convert > To Swift 1.2... </description>
<pubDate>Mon, 09 Feb 2015 11:00:00 PST</pubDate>
<content:encoded><![CDATA[<p>Today Swift 1.2 was released as part of Xcode 6.3 beta. This beta release includes a significantly enhanced Swift compiler, as well as new features in the Swift language itself. For the complete list of changes, read the <a href="https://developer.apple.com/devcenter/download.action?path=/Developer_Tools/Xcode_6.3_beta/Xcode_6.3_beta_Release_Notes.pdf">release notes</a>. This blog post will focus on the highlights.</p><h3>Compiler improvements</h3><p>The Swift 1.2 compiler was engineered to be more stable and to improve performance in every way. These changes also provide a better experience when working with Swift in Xcode. Some of the most visible improvements include:</p><ul><li><strong>Incremental builds</strong> ‚Äî Source files that haven‚Äôt changed will no longer be re-compiled by default, which will significantly improve build times for most common cases. Larger structural changes to your code may still require multiple files to be rebuilt.</li><li><strong>Faster executables</strong> ‚Äî Debug builds produce binaries that run considerably faster, and new optimizations deliver even better Release build performance.</li><li><strong>Better compiler diagnostics</strong> ‚Äî Clearer error and warning messages, along with new Fix-its, make it easier to write proper Swift 1.2 code.</li><li><strong>Stability improvements</strong> ‚Äî The most common compiler crashes have been fixed. You should also see fewer SourceKit warnings within the Xcode editor.</li></ul><h3>New language features</h3><p>In Swift 1.2, the language has been further refined to ensure safe, predictable behavior. We also continue to improve the interaction between Swift and Objective-C. Some of the more notable changes include:</p><ul><li><strong><span class="keyword">as!</span> for failable casts</strong> ‚Äî Casts that can fail at runtime are now expressed with the new <span class="keyword">as!</span> operator to make their potential for runtime failure clear to readers and maintainers of your code.</li><li><strong>Nullability may now be expressed in Objective-C headers</strong> ‚Äî New Objective-C extensions in Clang allow you to express the nullability of pointers and blocks in your Objective-C API. You can provide Objective-C frameworks that work great with Swift code, and improve your Swift experience when mixing and matching with Objective-C code in your own project.</li><li><strong>Swift enums can now be exported to Objective-C using the <span class="keyword">@objc</span> attribute</strong> ‚Äî For example, the following Swift code:</li></ul><a href="http://developer.apple.com/swift/blog/?id=22">[view code in blog]</a><p>imports into Objective-C as:</p><a href="http://developer.apple.com/swift/blog/?id=22">[view code in blog]</a><ul><li><strong><span class="keyword">let</span> constants are now more powerful and consistent</strong> ‚Äî The new rule is that a <span class="keyword">let</span> constant must be initialized before use (like a <span class="keyword">var</span>), and that it may only be initialized, not reassigned or mutated after initialization.</li></ul><p>This enables patterns like:</p><a href="http://developer.apple.com/swift/blog/?id=22">[view code in blog]</a><p>This formerly required the use of a <span class="keyword">var</span> even though there is no mutation taking place. Properties have been folded into this model to simplify their semantics in initializers as well.</p><ul><li><strong>More powerful opti